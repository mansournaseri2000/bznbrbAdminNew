/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/draftjs-to-html";
exports.ids = ["vendor-chunks/draftjs-to-html"];
exports.modules = {

/***/ "(ssr)/./node_modules/draftjs-to-html/lib/draftjs-to-html.js":
/*!*************************************************************!*\
  !*** ./node_modules/draftjs-to-html/lib/draftjs-to-html.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += \"\".concat(key, \":\").concat(value, \";\");\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return \"<strong>\".concat(content, \"</strong>\");\n    }\n\n    if (style === 'ITALIC') {\n      return \"<em>\".concat(content, \"</em>\");\n    }\n\n    if (style === 'UNDERLINE') {\n      return \"<ins>\".concat(content, \"</ins>\");\n    }\n\n    if (style === 'STRIKETHROUGH') {\n      return \"<del>\".concat(content, \"</del>\");\n    }\n\n    if (style === 'CODE') {\n      return \"<code>\".concat(content, \"</code>\");\n    }\n\n    if (style === 'SUPERSCRIPT') {\n      return \"<sup>\".concat(content, \"</sup>\");\n    }\n\n    if (style === 'SUBSCRIPT') {\n      return \"<sub>\".concat(content, \"</sub>\");\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += \"color: \".concat(styles.COLOR, \";\");\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '', \";\");\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n      }\n\n      styleString += '\"';\n      return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" class=\\\"wysiwyg-mention\\\" data-mention data-value=\\\"\").concat(entity.data.value, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" target=\\\"\").concat(targetOption, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'IMAGE') {\n      var alignment = entity.data.alignment;\n\n      if (alignment && alignment.length) {\n        return \"<div style=\\\"text-align:\".concat(alignment, \";\\\"><img src=\\\"\").concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/></div>\");\n      }\n\n      return \"<img src=\\\"\".concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/>\");\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return \"<iframe width=\\\"\".concat(entity.data.width, \"\\\" height=\\\"\").concat(entity.data.height, \"\\\" src=\\\"\").concat(entity.data.src, \"\\\" frameBorder=\\\"0\\\"></iframe>\");\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = Array.from(block.text);\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = \"<a href=\\\"\".concat(sectionText, \"\\\" class=\\\"wysiwyg-hashtag\\\">\").concat(sectionText, \"</a>\");\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push(\"<\".concat(blockTag));\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push(\"</\".concat(blockTag, \">\"));\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n\n  /**\n  * Function to check if a block is of type list.\n  */\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n    return listHtml.join('');\n  }\n\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZHJhZnRqcy10by1odG1sL2xpYi9kcmFmdGpzLXRvLWh0bWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDMkQ7QUFDN0QsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7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ZXphbmltLWJpcm9vbi8uL25vZGVfbW9kdWxlcy9kcmFmdGpzLXRvLWh0bWwvbGliL2RyYWZ0anMtdG8taHRtbC5qcz83MmFhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuZHJhZnRqc1RvSHRtbCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGV4ZWN1dGUgY2FsbGJhY2sgZm9yIGVhY2sga2V5LT52YWx1ZSBwYWlyLlxuICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoKG9iaiwgY2FsbGJhY2spIHtcbiAgICBpZiAob2JqKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgY2FsbGJhY2soa2V5LCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIHBhc3NlZCB0byBpdCBoYXMgbm8gY29udGVudC5cbiAgKi9cblxuICBmdW5jdGlvbiBpc0VtcHR5U3RyaW5nKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IG51bGwgfHwgc3RyLmxlbmd0aCA9PT0gMCB8fCBzdHIudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICogTWFwcGluZyBibG9jay10eXBlIHRvIGNvcnJlc3BvbmRpbmcgaHRtbCB0YWcuXG4gICovXG5cbiAgdmFyIGJsb2NrVHlwZXNNYXBwaW5nID0ge1xuICAgIHVuc3R5bGVkOiAncCcsXG4gICAgJ2hlYWRlci1vbmUnOiAnaDEnLFxuICAgICdoZWFkZXItdHdvJzogJ2gyJyxcbiAgICAnaGVhZGVyLXRocmVlJzogJ2gzJyxcbiAgICAnaGVhZGVyLWZvdXInOiAnaDQnLFxuICAgICdoZWFkZXItZml2ZSc6ICdoNScsXG4gICAgJ2hlYWRlci1zaXgnOiAnaDYnLFxuICAgICd1bm9yZGVyZWQtbGlzdC1pdGVtJzogJ3VsJyxcbiAgICAnb3JkZXJlZC1saXN0LWl0ZW0nOiAnb2wnLFxuICAgIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgICBjb2RlOiAncHJlJ1xuICB9O1xuICAvKipcbiAgKiBGdW5jdGlvbiB3aWxsIHJldHVybiBIVE1MIHRhZyBmb3IgYSBibG9jay5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRCbG9ja1RhZyh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgJiYgYmxvY2tUeXBlc01hcHBpbmdbdHlwZV07XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gd2lsbCByZXR1cm4gc3R5bGUgc3RyaW5nIGZvciBhIGJsb2NrLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldEJsb2NrU3R5bGUoZGF0YSkge1xuICAgIHZhciBzdHlsZXMgPSAnJztcbiAgICBmb3JFYWNoKGRhdGEsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc3R5bGVzICs9IFwiXCIuY29uY2F0KGtleSwgXCI6XCIpLmNvbmNhdCh2YWx1ZSwgXCI7XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gYXJyYXkgb2YgaGFzaHRhZy1zZWN0aW9ucyBpbiBibG9ja3MuXG4gICogVGhlc2Ugd2lsbCBiZSBhcmVhcyBpbiBibG9jayB3aGljaCBoYXZlIGhhc2h0YWdzIGFwcGxpY2FibGUgdG8gdGhlbS5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRIYXNodGFnUmFuZ2VzKGJsb2NrVGV4dCwgaGFzaHRhZ0NvbmZpZykge1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgaWYgKGhhc2h0YWdDb25maWcpIHtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICAgIHZhciB0ZXh0ID0gYmxvY2tUZXh0O1xuICAgICAgdmFyIHRyaWdnZXIgPSBoYXNodGFnQ29uZmlnLnRyaWdnZXIgfHwgJyMnO1xuICAgICAgdmFyIHNlcGFyYXRvciA9IGhhc2h0YWdDb25maWcuc2VwYXJhdG9yIHx8ICcgJztcblxuICAgICAgZm9yICg7IHRleHQubGVuZ3RoID4gMCAmJiBzdGFydEluZGV4ID49IDA7KSB7XG4gICAgICAgIGlmICh0ZXh0WzBdID09PSB0cmlnZ2VyKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgY291bnRlciA9IDA7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKHRyaWdnZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gdGV4dC5pbmRleE9mKHNlcGFyYXRvciArIHRyaWdnZXIpO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKHN0YXJ0SW5kZXggKyAoc2VwYXJhdG9yICsgdHJpZ2dlcikubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvdW50ZXIgKz0gc3RhcnRJbmRleCArIHNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgIHZhciBlbmRJbmRleCA9IHRleHQuaW5kZXhPZihzZXBhcmF0b3IpID49IDAgPyB0ZXh0LmluZGV4T2Yoc2VwYXJhdG9yKSA6IHRleHQubGVuZ3RoO1xuICAgICAgICAgIHZhciBoYXNodGFnID0gdGV4dC5zdWJzdHIoMCwgZW5kSW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGhhc2h0YWcgJiYgaGFzaHRhZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiBjb3VudGVyLFxuICAgICAgICAgICAgICBsZW5ndGg6IGhhc2h0YWcubGVuZ3RoICsgdHJpZ2dlci5sZW5ndGgsXG4gICAgICAgICAgICAgIHR5cGU6ICdIQVNIVEFHJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY291bnRlciArPSB0cmlnZ2VyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9ucztcbiAgfVxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBlbnRpdHktc2VjdGlvbnMgaW4gYmxvY2tzLlxuICAqIFRoZXNlIHdpbGwgYmUgYXJlYXMgaW4gYmxvY2sgd2hpY2ggaGF2ZSBzYW1lIGVudGl0eSBvciBubyBlbnRpdHkgYXBwbGljYWJsZSB0byB0aGVtLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U2VjdGlvbnMoYmxvY2ssIGhhc2h0YWdDb25maWcpIHtcbiAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgdmFyIHNlY3Rpb25SYW5nZXMgPSBibG9jay5lbnRpdHlSYW5nZXMubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIG9mZnNldCA9IHJhbmdlLm9mZnNldCxcbiAgICAgICAgICBsZW5ndGggPSByYW5nZS5sZW5ndGgsXG4gICAgICAgICAga2V5ID0gcmFuZ2Uua2V5O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdHlwZTogJ0VOVElUWSdcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc2VjdGlvblJhbmdlcyA9IHNlY3Rpb25SYW5nZXMuY29uY2F0KGdldEhhc2h0YWdSYW5nZXMoYmxvY2sudGV4dCwgaGFzaHRhZ0NvbmZpZykpO1xuICAgIHNlY3Rpb25SYW5nZXMgPSBzZWN0aW9uUmFuZ2VzLnNvcnQoZnVuY3Rpb24gKHMxLCBzMikge1xuICAgICAgcmV0dXJuIHMxLm9mZnNldCAtIHMyLm9mZnNldDtcbiAgICB9KTtcbiAgICBzZWN0aW9uUmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIGlmIChyLm9mZnNldCA+IGxhc3RPZmZzZXQpIHtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgc3RhcnQ6IGxhc3RPZmZzZXQsXG4gICAgICAgICAgZW5kOiByLm9mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgIHN0YXJ0OiByLm9mZnNldCxcbiAgICAgICAgZW5kOiByLm9mZnNldCArIHIubGVuZ3RoLFxuICAgICAgICBlbnRpdHlLZXk6IHIua2V5LFxuICAgICAgICB0eXBlOiByLnR5cGVcbiAgICAgIH0pO1xuICAgICAgbGFzdE9mZnNldCA9IHIub2Zmc2V0ICsgci5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBpZiAobGFzdE9mZnNldCA8IGJsb2NrLnRleHQubGVuZ3RoKSB7XG4gICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IGxhc3RPZmZzZXQsXG4gICAgICAgIGVuZDogYmxvY2sudGV4dC5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9ucztcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgYmxvY2sgaXMgYW4gYXRvbWljIGVudGl0eSBibG9jay5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzQXRvbWljRW50aXR5QmxvY2soYmxvY2spIHtcbiAgICBpZiAoYmxvY2suZW50aXR5UmFuZ2VzLmxlbmd0aCA+IDAgJiYgKGlzRW1wdHlTdHJpbmcoYmxvY2sudGV4dCkgfHwgYmxvY2sudHlwZSA9PT0gJ2F0b21pYycpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFycmF5IG9mIGlubGluZSBzdHlsZXMgYXBwbGljYWJsZSB0byB0aGUgYmxvY2suXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRTdHlsZUFycmF5Rm9yQmxvY2soYmxvY2spIHtcbiAgICB2YXIgdGV4dCA9IGJsb2NrLnRleHQsXG4gICAgICAgIGlubGluZVN0eWxlUmFuZ2VzID0gYmxvY2suaW5saW5lU3R5bGVSYW5nZXM7XG4gICAgdmFyIGlubGluZVN0eWxlcyA9IHtcbiAgICAgIEJPTEQ6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBJVEFMSUM6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBVTkRFUkxJTkU6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBTVFJJS0VUSFJPVUdIOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgQ09ERTogbmV3IEFycmF5KHRleHQubGVuZ3RoKSxcbiAgICAgIFNVUEVSU0NSSVBUOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgU1VCU0NSSVBUOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgQ09MT1I6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBCR0NPTE9SOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgRk9OVFNJWkU6IG5ldyBBcnJheSh0ZXh0Lmxlbmd0aCksXG4gICAgICBGT05URkFNSUxZOiBuZXcgQXJyYXkodGV4dC5sZW5ndGgpLFxuICAgICAgbGVuZ3RoOiB0ZXh0Lmxlbmd0aFxuICAgIH07XG5cbiAgICBpZiAoaW5saW5lU3R5bGVSYW5nZXMgJiYgaW5saW5lU3R5bGVSYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgaW5saW5lU3R5bGVSYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHJhbmdlLm9mZnNldDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG9mZnNldCArIHJhbmdlLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAocmFuZ2Uuc3R5bGUuaW5kZXhPZignY29sb3ItJykgPT09IDApIHtcbiAgICAgICAgICAgIGlubGluZVN0eWxlcy5DT0xPUltpXSA9IHJhbmdlLnN0eWxlLnN1YnN0cmluZyg2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnN0eWxlLmluZGV4T2YoJ2JnY29sb3ItJykgPT09IDApIHtcbiAgICAgICAgICAgIGlubGluZVN0eWxlcy5CR0NPTE9SW2ldID0gcmFuZ2Uuc3R5bGUuc3Vic3RyaW5nKDgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2Uuc3R5bGUuaW5kZXhPZignZm9udHNpemUtJykgPT09IDApIHtcbiAgICAgICAgICAgIGlubGluZVN0eWxlcy5GT05UU0laRVtpXSA9IHJhbmdlLnN0eWxlLnN1YnN0cmluZyg5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLnN0eWxlLmluZGV4T2YoJ2ZvbnRmYW1pbHktJykgPT09IDApIHtcbiAgICAgICAgICAgIGlubGluZVN0eWxlcy5GT05URkFNSUxZW2ldID0gcmFuZ2Uuc3R5bGUuc3Vic3RyaW5nKDExKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlubGluZVN0eWxlc1tyYW5nZS5zdHlsZV0pIHtcbiAgICAgICAgICAgIGlubGluZVN0eWxlc1tyYW5nZS5zdHlsZV1baV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlubGluZVN0eWxlcztcbiAgfVxuICAvKipcbiAgKiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gaW5saW5lIHN0eWxlIGFwcGxpY2FibGUgYXQgc29tZSBvZmZzZXQgd2l0aGluIGEgYmxvY2suXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRTdHlsZXNBdE9mZnNldChpbmxpbmVTdHlsZXMsIG9mZnNldCkge1xuICAgIHZhciBzdHlsZXMgPSB7fTtcblxuICAgIGlmIChpbmxpbmVTdHlsZXMuQ09MT1Jbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLkNPTE9SID0gaW5saW5lU3R5bGVzLkNPTE9SW29mZnNldF07XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5CR0NPTE9SW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5CR0NPTE9SID0gaW5saW5lU3R5bGVzLkJHQ09MT1Jbb2Zmc2V0XTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLkZPTlRTSVpFW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5GT05UU0laRSA9IGlubGluZVN0eWxlcy5GT05UU0laRVtvZmZzZXRdO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuRk9OVEZBTUlMWVtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuRk9OVEZBTUlMWSA9IGlubGluZVN0eWxlcy5GT05URkFNSUxZW29mZnNldF07XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5VTkRFUkxJTkVbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLlVOREVSTElORSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5JVEFMSUNbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLklUQUxJQyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5CT0xEW29mZnNldF0pIHtcbiAgICAgIHN0eWxlcy5CT0xEID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5saW5lU3R5bGVzLlNUUklLRVRIUk9VR0hbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLlNUUklLRVRIUk9VR0ggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpbmxpbmVTdHlsZXMuQ09ERVtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuQ09ERSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5TVUJTQ1JJUFRbb2Zmc2V0XSkge1xuICAgICAgc3R5bGVzLlNVQlNDUklQVCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlubGluZVN0eWxlcy5TVVBFUlNDUklQVFtvZmZzZXRdKSB7XG4gICAgICBzdHlsZXMuU1VQRVJTQ1JJUFQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gcmV0dXJucyB0cnVlIGZvciBhIHNldCBvZiBzdHlsZXMgaWYgdGhlIHZhbHVlIG9mIHRoZXNlIHN0eWxlcyBhdCBhbiBvZmZzZXRcbiAgKiBhcmUgc2FtZSBhcyB0aGF0IG9uIHRoZSBwcmV2aW91cyBvZmZzZXQuXG4gICovXG5cbiAgZnVuY3Rpb24gc2FtZVN0eWxlQXNQcmV2aW91cyhpbmxpbmVTdHlsZXMsIHN0eWxlcywgaW5kZXgpIHtcbiAgICB2YXIgc2FtZVN0eWxlZCA9IHRydWU7XG5cbiAgICBpZiAoaW5kZXggPiAwICYmIGluZGV4IDwgaW5saW5lU3R5bGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHNhbWVTdHlsZWQgPSBzYW1lU3R5bGVkICYmIGlubGluZVN0eWxlc1tzdHlsZV1baW5kZXhdID09PSBpbmxpbmVTdHlsZXNbc3R5bGVdW2luZGV4IC0gMV07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FtZVN0eWxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzYW1lU3R5bGVkO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHJldHVybnMgaHRtbCBmb3IgdGV4dCBkZXBlbmRpbmcgb24gaW5saW5lIHN0eWxlIHRhZ3MgYXBwbGljYWJsZSB0byBpdC5cbiAgKi9cblxuICBmdW5jdGlvbiBhZGRJbmxpbmVTdHlsZU1hcmt1cChzdHlsZSwgY29udGVudCkge1xuICAgIGlmIChzdHlsZSA9PT0gJ0JPTEQnKSB7XG4gICAgICByZXR1cm4gXCI8c3Ryb25nPlwiLmNvbmNhdChjb250ZW50LCBcIjwvc3Ryb25nPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgPT09ICdJVEFMSUMnKSB7XG4gICAgICByZXR1cm4gXCI8ZW0+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9lbT5cIik7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlID09PSAnVU5ERVJMSU5FJykge1xuICAgICAgcmV0dXJuIFwiPGlucz5cIi5jb25jYXQoY29udGVudCwgXCI8L2lucz5cIik7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlID09PSAnU1RSSUtFVEhST1VHSCcpIHtcbiAgICAgIHJldHVybiBcIjxkZWw+XCIuY29uY2F0KGNvbnRlbnQsIFwiPC9kZWw+XCIpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZSA9PT0gJ0NPREUnKSB7XG4gICAgICByZXR1cm4gXCI8Y29kZT5cIi5jb25jYXQoY29udGVudCwgXCI8L2NvZGU+XCIpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZSA9PT0gJ1NVUEVSU0NSSVBUJykge1xuICAgICAgcmV0dXJuIFwiPHN1cD5cIi5jb25jYXQoY29udGVudCwgXCI8L3N1cD5cIik7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlID09PSAnU1VCU0NSSVBUJykge1xuICAgICAgcmV0dXJuIFwiPHN1Yj5cIi5jb25jYXQoY29udGVudCwgXCI8L3N1Yj5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdGV4dCBmb3IgZ2l2ZW4gc2VjdGlvbiBvZiBibG9jayBhZnRlciBkb2luZyByZXF1aXJlZCBjaGFyYWN0ZXIgcmVwbGFjZW1lbnRzLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldFNlY3Rpb25UZXh0KHRleHQpIHtcbiAgICBpZiAodGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBjaGFycyA9IHRleHQubWFwKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnPGJyPic7XG5cbiAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuXG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuXG4gICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJyZndDsnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHJldHVybnMgaHRtbCBmb3IgdGV4dCBkZXBlbmRpbmcgb24gaW5saW5lIHN0eWxlIHRhZ3MgYXBwbGljYWJsZSB0byBpdC5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGFkZFN0eWxlUHJvcGVydHlNYXJrdXAoc3R5bGVzLCB0ZXh0KSB7XG4gICAgaWYgKHN0eWxlcyAmJiAoc3R5bGVzLkNPTE9SIHx8IHN0eWxlcy5CR0NPTE9SIHx8IHN0eWxlcy5GT05UU0laRSB8fCBzdHlsZXMuRk9OVEZBTUlMWSkpIHtcbiAgICAgIHZhciBzdHlsZVN0cmluZyA9ICdzdHlsZT1cIic7XG5cbiAgICAgIGlmIChzdHlsZXMuQ09MT1IpIHtcbiAgICAgICAgc3R5bGVTdHJpbmcgKz0gXCJjb2xvcjogXCIuY29uY2F0KHN0eWxlcy5DT0xPUiwgXCI7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGVzLkJHQ09MT1IpIHtcbiAgICAgICAgc3R5bGVTdHJpbmcgKz0gXCJiYWNrZ3JvdW5kLWNvbG9yOiBcIi5jb25jYXQoc3R5bGVzLkJHQ09MT1IsIFwiO1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlcy5GT05UU0laRSkge1xuICAgICAgICBzdHlsZVN0cmluZyArPSBcImZvbnQtc2l6ZTogXCIuY29uY2F0KHN0eWxlcy5GT05UU0laRSkuY29uY2F0KC9eXFxkKyQvLnRlc3Qoc3R5bGVzLkZPTlRTSVpFKSA/ICdweCcgOiAnJywgXCI7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGVzLkZPTlRGQU1JTFkpIHtcbiAgICAgICAgc3R5bGVTdHJpbmcgKz0gXCJmb250LWZhbWlseTogXCIuY29uY2F0KHN0eWxlcy5GT05URkFNSUxZLCBcIjtcIik7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlU3RyaW5nICs9ICdcIic7XG4gICAgICByZXR1cm4gXCI8c3BhbiBcIi5jb25jYXQoc3R5bGVTdHJpbmcsIFwiPlwiKS5jb25jYXQodGV4dCwgXCI8L3NwYW4+XCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHdpbGwgcmV0dXJuIG1hcmt1cCBmb3IgRW50aXR5LlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldEVudGl0eU1hcmt1cChlbnRpdHlNYXAsIGVudGl0eUtleSwgdGV4dCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSB7XG4gICAgdmFyIGVudGl0eSA9IGVudGl0eU1hcFtlbnRpdHlLZXldO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21FbnRpdHlUcmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBodG1sID0gY3VzdG9tRW50aXR5VHJhbnNmb3JtKGVudGl0eSwgdGV4dCk7XG5cbiAgICAgIGlmIChodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ01FTlRJT04nKSB7XG4gICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIi5jb25jYXQoZW50aXR5LmRhdGEudXJsLCBcIlxcXCIgY2xhc3M9XFxcInd5c2l3eWctbWVudGlvblxcXCIgZGF0YS1tZW50aW9uIGRhdGEtdmFsdWU9XFxcIlwiKS5jb25jYXQoZW50aXR5LmRhdGEudmFsdWUsIFwiXFxcIj5cIikuY29uY2F0KHRleHQsIFwiPC9hPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZW50aXR5LnR5cGUgPT09ICdMSU5LJykge1xuICAgICAgdmFyIHRhcmdldE9wdGlvbiA9IGVudGl0eS5kYXRhLnRhcmdldE9wdGlvbiB8fCAnX3NlbGYnO1xuICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIuY29uY2F0KGVudGl0eS5kYXRhLnVybCwgXCJcXFwiIHRhcmdldD1cXFwiXCIpLmNvbmNhdCh0YXJnZXRPcHRpb24sIFwiXFxcIj5cIikuY29uY2F0KHRleHQsIFwiPC9hPlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZW50aXR5LnR5cGUgPT09ICdJTUFHRScpIHtcbiAgICAgIHZhciBhbGlnbm1lbnQgPSBlbnRpdHkuZGF0YS5hbGlnbm1lbnQ7XG5cbiAgICAgIGlmIChhbGlnbm1lbnQgJiYgYWxpZ25tZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gXCI8ZGl2IHN0eWxlPVxcXCJ0ZXh0LWFsaWduOlwiLmNvbmNhdChhbGlnbm1lbnQsIFwiO1xcXCI+PGltZyBzcmM9XFxcIlwiKS5jb25jYXQoZW50aXR5LmRhdGEuc3JjLCBcIlxcXCIgYWx0PVxcXCJcIikuY29uY2F0KGVudGl0eS5kYXRhLmFsdCwgXCJcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6IFwiKS5jb25jYXQoZW50aXR5LmRhdGEuaGVpZ2h0LCBcIjt3aWR0aDogXCIpLmNvbmNhdChlbnRpdHkuZGF0YS53aWR0aCwgXCJcXFwiLz48L2Rpdj5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIjxpbWcgc3JjPVxcXCJcIi5jb25jYXQoZW50aXR5LmRhdGEuc3JjLCBcIlxcXCIgYWx0PVxcXCJcIikuY29uY2F0KGVudGl0eS5kYXRhLmFsdCwgXCJcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6IFwiKS5jb25jYXQoZW50aXR5LmRhdGEuaGVpZ2h0LCBcIjt3aWR0aDogXCIpLmNvbmNhdChlbnRpdHkuZGF0YS53aWR0aCwgXCJcXFwiLz5cIik7XG4gICAgfVxuXG4gICAgaWYgKGVudGl0eS50eXBlID09PSAnRU1CRURERURfTElOSycpIHtcbiAgICAgIHJldHVybiBcIjxpZnJhbWUgd2lkdGg9XFxcIlwiLmNvbmNhdChlbnRpdHkuZGF0YS53aWR0aCwgXCJcXFwiIGhlaWdodD1cXFwiXCIpLmNvbmNhdChlbnRpdHkuZGF0YS5oZWlnaHQsIFwiXFxcIiBzcmM9XFxcIlwiKS5jb25jYXQoZW50aXR5LmRhdGEuc3JjLCBcIlxcXCIgZnJhbWVCb3JkZXI9XFxcIjBcXFwiPjwvaWZyYW1lPlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICAvKipcbiAgKiBGb3IgYSBnaXZlbiBzZWN0aW9uIGluIGEgYmxvY2sgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgZnVydGhlciBsaXN0IG9mIHNlY3Rpb25zLFxuICAqIHdpdGggc2ltaWxhciBpbmxpbmUgc3R5bGVzIGFwcGxpY2FibGUgdG8gdGhlbS5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldElubGluZVN0eWxlU2VjdGlvbnMoYmxvY2ssIHN0eWxlcywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzdHlsZVNlY3Rpb25zID0gW107XG4gICAgdmFyIHRleHQgPSBBcnJheS5mcm9tKGJsb2NrLnRleHQpO1xuXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGlubGluZVN0eWxlcyA9IGdldFN0eWxlQXJyYXlGb3JCbG9jayhibG9jayk7XG4gICAgICB2YXIgc2VjdGlvbjtcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgIT09IHN0YXJ0ICYmIHNhbWVTdHlsZUFzUHJldmlvdXMoaW5saW5lU3R5bGVzLCBzdHlsZXMsIGkpKSB7XG4gICAgICAgICAgc2VjdGlvbi50ZXh0LnB1c2godGV4dFtpXSk7XG4gICAgICAgICAgc2VjdGlvbi5lbmQgPSBpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWN0aW9uID0ge1xuICAgICAgICAgICAgc3R5bGVzOiBnZXRTdHlsZXNBdE9mZnNldChpbmxpbmVTdHlsZXMsIGkpLFxuICAgICAgICAgICAgdGV4dDogW3RleHRbaV1dLFxuICAgICAgICAgICAgc3RhcnQ6IGksXG4gICAgICAgICAgICBlbmQ6IGkgKyAxXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzdHlsZVNlY3Rpb25zLnB1c2goc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVTZWN0aW9ucztcbiAgfVxuICAvKipcbiAgKiBSZXBsYWNlIGxlYWRpbmcgYmxhbmsgc3BhY2VzIGJ5ICZuYnNwO1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gdHJpbUxlYWRpbmdaZXJvcyhzZWN0aW9uVGV4dCkge1xuICAgIGlmIChzZWN0aW9uVGV4dCkge1xuICAgICAgdmFyIHJlcGxhY2VkVGV4dCA9IHNlY3Rpb25UZXh0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VkVGV4dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2VjdGlvblRleHRbaV0gPT09ICcgJykge1xuICAgICAgICAgIHJlcGxhY2VkVGV4dCA9IHJlcGxhY2VkVGV4dC5yZXBsYWNlKCcgJywgJyZuYnNwOycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXBsYWNlZFRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25UZXh0O1xuICB9XG4gIC8qKlxuICAqIFJlcGxhY2UgdHJhaWxpbmcgYmxhbmsgc3BhY2VzIGJ5ICZuYnNwO1xuICAqL1xuXG4gIGZ1bmN0aW9uIHRyaW1UcmFpbGluZ1plcm9zKHNlY3Rpb25UZXh0KSB7XG4gICAgaWYgKHNlY3Rpb25UZXh0KSB7XG4gICAgICB2YXIgcmVwbGFjZWRUZXh0ID0gc2VjdGlvblRleHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZXBsYWNlZFRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VkVGV4dFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgcmVwbGFjZWRUZXh0ID0gXCJcIi5jb25jYXQocmVwbGFjZWRUZXh0LnN1YnN0cmluZygwLCBpKSwgXCImbmJzcDtcIikuY29uY2F0KHJlcGxhY2VkVGV4dC5zdWJzdHJpbmcoaSArIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVwbGFjZWRUZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uVGV4dDtcbiAgfVxuICAvKipcbiAgKiBUaGUgbWV0aG9kIHJldHVybnMgbWFya3VwIGZvciBzZWN0aW9uIHRvIHdoaWNoIGlubGluZSBzdHlsZXNcbiAgKiBsaWtlIEJPTEQsIElUQUxJQywgVU5ERVJMSU5FLCBTVFJJS0VUSFJPVUdILCBDT0RFLCBTVVBFUlNDUklQVCwgU1VCU0NSSVBUIGFyZSBhcHBsaWNhYmxlLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGdldFN0eWxlVGFnU2VjdGlvbk1hcmt1cChzdHlsZVNlY3Rpb24pIHtcbiAgICB2YXIgc3R5bGVzID0gc3R5bGVTZWN0aW9uLnN0eWxlcyxcbiAgICAgICAgdGV4dCA9IHN0eWxlU2VjdGlvbi50ZXh0O1xuICAgIHZhciBjb250ZW50ID0gZ2V0U2VjdGlvblRleHQodGV4dCk7XG4gICAgZm9yRWFjaChzdHlsZXMsIGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUpIHtcbiAgICAgIGNvbnRlbnQgPSBhZGRJbmxpbmVTdHlsZU1hcmt1cChzdHlsZSwgY29udGVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICogVGhlIG1ldGhvZCByZXR1cm5zIG1hcmt1cCBmb3Igc2VjdGlvbiB0byB3aGljaCBpbmxpbmUgc3R5bGVzXG4gIGxpa2UgY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGZvbnQtc2l6ZSBhcmUgYXBwbGljYWJsZS5cbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldElubGluZVN0eWxlU2VjdGlvbk1hcmt1cChibG9jaywgc3R5bGVTZWN0aW9uKSB7XG4gICAgdmFyIHN0eWxlVGFnU2VjdGlvbnMgPSBnZXRJbmxpbmVTdHlsZVNlY3Rpb25zKGJsb2NrLCBbJ0JPTEQnLCAnSVRBTElDJywgJ1VOREVSTElORScsICdTVFJJS0VUSFJPVUdIJywgJ0NPREUnLCAnU1VQRVJTQ1JJUFQnLCAnU1VCU0NSSVBUJ10sIHN0eWxlU2VjdGlvbi5zdGFydCwgc3R5bGVTZWN0aW9uLmVuZCk7XG4gICAgdmFyIHN0eWxlU2VjdGlvblRleHQgPSAnJztcbiAgICBzdHlsZVRhZ1NlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlUHJvcGVydHlTZWN0aW9uKSB7XG4gICAgICBzdHlsZVNlY3Rpb25UZXh0ICs9IGdldFN0eWxlVGFnU2VjdGlvbk1hcmt1cChzdHlsZVByb3BlcnR5U2VjdGlvbik7XG4gICAgfSk7XG4gICAgc3R5bGVTZWN0aW9uVGV4dCA9IGFkZFN0eWxlUHJvcGVydHlNYXJrdXAoc3R5bGVTZWN0aW9uLnN0eWxlcywgc3R5bGVTZWN0aW9uVGV4dCk7XG4gICAgcmV0dXJuIHN0eWxlU2VjdGlvblRleHQ7XG4gIH1cbiAgLypcbiAgKiBUaGUgbWV0aG9kIHJldHVybnMgbWFya3VwIGZvciBhbiBlbnRpdHkgc2VjdGlvbi5cbiAgKiBBbiBlbnRpdHkgc2VjdGlvbiBpcyBhIGNvbnRpbnVvdXMgc2VjdGlvbiBpbiBhIGJsb2NrXG4gICogdG8gd2hpY2ggc2FtZSBlbnRpdHkgb3Igbm8gZW50aXR5IGlzIGFwcGxpY2FibGUuXG4gICovXG5cblxuICBmdW5jdGlvbiBnZXRTZWN0aW9uTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIHNlY3Rpb24sIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkge1xuICAgIHZhciBlbnRpdHlJbmxpbmVNYXJrdXAgPSBbXTtcbiAgICB2YXIgaW5saW5lU3R5bGVTZWN0aW9ucyA9IGdldElubGluZVN0eWxlU2VjdGlvbnMoYmxvY2ssIFsnQ09MT1InLCAnQkdDT0xPUicsICdGT05UU0laRScsICdGT05URkFNSUxZJ10sIHNlY3Rpb24uc3RhcnQsIHNlY3Rpb24uZW5kKTtcbiAgICBpbmxpbmVTdHlsZVNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlU2VjdGlvbikge1xuICAgICAgZW50aXR5SW5saW5lTWFya3VwLnB1c2goZ2V0SW5saW5lU3R5bGVTZWN0aW9uTWFya3VwKGJsb2NrLCBzdHlsZVNlY3Rpb24pKTtcbiAgICB9KTtcbiAgICB2YXIgc2VjdGlvblRleHQgPSBlbnRpdHlJbmxpbmVNYXJrdXAuam9pbignJyk7XG5cbiAgICBpZiAoc2VjdGlvbi50eXBlID09PSAnRU5USVRZJykge1xuICAgICAgaWYgKHNlY3Rpb24uZW50aXR5S2V5ICE9PSB1bmRlZmluZWQgJiYgc2VjdGlvbi5lbnRpdHlLZXkgIT09IG51bGwpIHtcbiAgICAgICAgc2VjdGlvblRleHQgPSBnZXRFbnRpdHlNYXJrdXAoZW50aXR5TWFwLCBzZWN0aW9uLmVudGl0eUtleSwgc2VjdGlvblRleHQsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VjdGlvbi50eXBlID09PSAnSEFTSFRBRycpIHtcbiAgICAgIHNlY3Rpb25UZXh0ID0gXCI8YSBocmVmPVxcXCJcIi5jb25jYXQoc2VjdGlvblRleHQsIFwiXFxcIiBjbGFzcz1cXFwid3lzaXd5Zy1oYXNodGFnXFxcIj5cIikuY29uY2F0KHNlY3Rpb25UZXh0LCBcIjwvYT5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25UZXh0O1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBtYXJrdXAgZm9yIGJsb2NrIHByZXNlcnZpbmcgdGhlIGlubGluZSBzdHlsZXMgYW5kXG4gICogc3BlY2lhbCBjaGFyYWN0ZXJzIGxpa2UgbmV3bGluZXMgb3IgYmxhbmsgc3BhY2VzLlxuICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tJbm5lck1hcmt1cChibG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pIHtcbiAgICB2YXIgYmxvY2tNYXJrdXAgPSBbXTtcbiAgICB2YXIgc2VjdGlvbnMgPSBnZXRTZWN0aW9ucyhibG9jaywgaGFzaHRhZ0NvbmZpZyk7XG4gICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbiwgaW5kZXgpIHtcbiAgICAgIHZhciBzZWN0aW9uVGV4dCA9IGdldFNlY3Rpb25NYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgc2VjdGlvbiwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKTtcblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHNlY3Rpb25UZXh0ID0gdHJpbUxlYWRpbmdaZXJvcyhzZWN0aW9uVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gc2VjdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICBzZWN0aW9uVGV4dCA9IHRyaW1UcmFpbGluZ1plcm9zKHNlY3Rpb25UZXh0KTtcbiAgICAgIH1cblxuICAgICAgYmxvY2tNYXJrdXAucHVzaChzZWN0aW9uVGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJsb2NrTWFya3VwLmpvaW4oJycpO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHdpbGwgcmV0dXJuIGh0bWwgZm9yIHRoZSBibG9jay5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRCbG9ja01hcmt1cChibG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSB7XG4gICAgdmFyIGJsb2NrSHRtbCA9IFtdO1xuXG4gICAgaWYgKGlzQXRvbWljRW50aXR5QmxvY2soYmxvY2spKSB7XG4gICAgICBibG9ja0h0bWwucHVzaChnZXRFbnRpdHlNYXJrdXAoZW50aXR5TWFwLCBibG9jay5lbnRpdHlSYW5nZXNbMF0ua2V5LCB1bmRlZmluZWQsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmxvY2tUYWcgPSBnZXRCbG9ja1RhZyhibG9jay50eXBlKTtcblxuICAgICAgaWYgKGJsb2NrVGFnKSB7XG4gICAgICAgIGJsb2NrSHRtbC5wdXNoKFwiPFwiLmNvbmNhdChibG9ja1RhZykpO1xuICAgICAgICB2YXIgYmxvY2tTdHlsZSA9IGdldEJsb2NrU3R5bGUoYmxvY2suZGF0YSk7XG5cbiAgICAgICAgaWYgKGJsb2NrU3R5bGUpIHtcbiAgICAgICAgICBibG9ja0h0bWwucHVzaChcIiBzdHlsZT1cXFwiXCIuY29uY2F0KGJsb2NrU3R5bGUsIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uYWwpIHtcbiAgICAgICAgICBibG9ja0h0bWwucHVzaCgnIGRpciA9IFwiYXV0b1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBibG9ja0h0bWwucHVzaCgnPicpO1xuICAgICAgICBibG9ja0h0bWwucHVzaChnZXRCbG9ja0lubmVyTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkpO1xuICAgICAgICBibG9ja0h0bWwucHVzaChcIjwvXCIuY29uY2F0KGJsb2NrVGFnLCBcIj5cIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJsb2NrSHRtbC5wdXNoKCdcXG4nKTtcbiAgICByZXR1cm4gYmxvY2tIdG1sLmpvaW4oJycpO1xuICB9XG5cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBibG9jayBpcyBvZiB0eXBlIGxpc3QuXG4gICovXG5cbiAgZnVuY3Rpb24gaXNMaXN0KGJsb2NrVHlwZSkge1xuICAgIHJldHVybiBibG9ja1R5cGUgPT09ICd1bm9yZGVyZWQtbGlzdC1pdGVtJyB8fCBibG9ja1R5cGUgPT09ICdvcmRlcmVkLWxpc3QtaXRlbSc7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gd2lsbCByZXR1cm4gaHRtbCBtYXJrdXAgZm9yIGEgbGlzdCBibG9jay5cbiAgKi9cblxuICBmdW5jdGlvbiBnZXRMaXN0TWFya3VwKGxpc3RCbG9ja3MsIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkge1xuICAgIHZhciBsaXN0SHRtbCA9IFtdO1xuICAgIHZhciBuZXN0ZWRMaXN0QmxvY2sgPSBbXTtcbiAgICB2YXIgcHJldmlvdXNCbG9jaztcbiAgICBsaXN0QmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICB2YXIgbmVzdGVkQmxvY2sgPSBmYWxzZTtcblxuICAgICAgaWYgKCFwcmV2aW91c0Jsb2NrKSB7XG4gICAgICAgIGxpc3RIdG1sLnB1c2goXCI8XCIuY29uY2F0KGdldEJsb2NrVGFnKGJsb2NrLnR5cGUpLCBcIj5cXG5cIikpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91c0Jsb2NrLnR5cGUgIT09IGJsb2NrLnR5cGUpIHtcbiAgICAgICAgbGlzdEh0bWwucHVzaChcIjwvXCIuY29uY2F0KGdldEJsb2NrVGFnKHByZXZpb3VzQmxvY2sudHlwZSksIFwiPlxcblwiKSk7XG4gICAgICAgIGxpc3RIdG1sLnB1c2goXCI8XCIuY29uY2F0KGdldEJsb2NrVGFnKGJsb2NrLnR5cGUpLCBcIj5cXG5cIikpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91c0Jsb2NrLmRlcHRoID09PSBibG9jay5kZXB0aCkge1xuICAgICAgICBpZiAobmVzdGVkTGlzdEJsb2NrICYmIG5lc3RlZExpc3RCbG9jay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGlzdEh0bWwucHVzaChnZXRMaXN0TWFya3VwKG5lc3RlZExpc3RCbG9jaywgZW50aXR5TWFwLCBoYXNodGFnQ29uZmlnLCBkaXJlY3Rpb25hbCwgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSk7XG4gICAgICAgICAgbmVzdGVkTGlzdEJsb2NrID0gW107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lc3RlZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgbmVzdGVkTGlzdEJsb2NrLnB1c2goYmxvY2spO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5lc3RlZEJsb2NrKSB7XG4gICAgICAgIGxpc3RIdG1sLnB1c2goJzxsaScpO1xuICAgICAgICB2YXIgYmxvY2tTdHlsZSA9IGdldEJsb2NrU3R5bGUoYmxvY2suZGF0YSk7XG5cbiAgICAgICAgaWYgKGJsb2NrU3R5bGUpIHtcbiAgICAgICAgICBsaXN0SHRtbC5wdXNoKFwiIHN0eWxlPVxcXCJcIi5jb25jYXQoYmxvY2tTdHlsZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3Rpb25hbCkge1xuICAgICAgICAgIGxpc3RIdG1sLnB1c2goJyBkaXIgPSBcImF1dG9cIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdEh0bWwucHVzaCgnPicpO1xuICAgICAgICBsaXN0SHRtbC5wdXNoKGdldEJsb2NrSW5uZXJNYXJrdXAoYmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgY3VzdG9tRW50aXR5VHJhbnNmb3JtKSk7XG4gICAgICAgIGxpc3RIdG1sLnB1c2goJzwvbGk+XFxuJyk7XG4gICAgICAgIHByZXZpb3VzQmxvY2sgPSBibG9jaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChuZXN0ZWRMaXN0QmxvY2sgJiYgbmVzdGVkTGlzdEJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpc3RIdG1sLnB1c2goZ2V0TGlzdE1hcmt1cChuZXN0ZWRMaXN0QmxvY2ssIGVudGl0eU1hcCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkpO1xuICAgIH1cblxuICAgIGxpc3RIdG1sLnB1c2goXCI8L1wiLmNvbmNhdChnZXRCbG9ja1RhZyhwcmV2aW91c0Jsb2NrLnR5cGUpLCBcIj5cXG5cIikpO1xuICAgIHJldHVybiBsaXN0SHRtbC5qb2luKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAqIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlIGh0bWwgbWFya3VwIGZvciBnaXZlbiBkcmFmdGpzIGVkaXRvckNvbnRlbnQuXG4gICovXG5cbiAgZnVuY3Rpb24gZHJhZnRUb0h0bWwoZWRpdG9yQ29udGVudCwgaGFzaHRhZ0NvbmZpZywgZGlyZWN0aW9uYWwsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSkge1xuICAgIHZhciBodG1sID0gW107XG5cbiAgICBpZiAoZWRpdG9yQ29udGVudCkge1xuICAgICAgdmFyIGJsb2NrcyA9IGVkaXRvckNvbnRlbnQuYmxvY2tzLFxuICAgICAgICAgIGVudGl0eU1hcCA9IGVkaXRvckNvbnRlbnQuZW50aXR5TWFwO1xuXG4gICAgICBpZiAoYmxvY2tzICYmIGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsaXN0QmxvY2tzID0gW107XG4gICAgICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgIGlmIChpc0xpc3QoYmxvY2sudHlwZSkpIHtcbiAgICAgICAgICAgIGxpc3RCbG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsaXN0QmxvY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3RIdG1sID0gZ2V0TGlzdE1hcmt1cChsaXN0QmxvY2tzLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGN1c3RvbUVudGl0eVRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuXG4gICAgICAgICAgICAgIGh0bWwucHVzaChsaXN0SHRtbCk7XG4gICAgICAgICAgICAgIGxpc3RCbG9ja3MgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJsb2NrSHRtbCA9IGdldEJsb2NrTWFya3VwKGJsb2NrLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgaHRtbC5wdXNoKGJsb2NrSHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobGlzdEJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxpc3RIdG1sID0gZ2V0TGlzdE1hcmt1cChsaXN0QmxvY2tzLCBlbnRpdHlNYXAsIGhhc2h0YWdDb25maWcsIGRpcmVjdGlvbmFsLCBjdXN0b21FbnRpdHlUcmFuc2Zvcm0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cblxuICAgICAgICAgIGh0bWwucHVzaChsaXN0SHRtbCk7XG4gICAgICAgICAgbGlzdEJsb2NrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWwuam9pbignJyk7XG4gIH1cblxuICByZXR1cm4gZHJhZnRUb0h0bWw7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/draftjs-to-html/lib/draftjs-to-html.js\n");

/***/ })

};
;