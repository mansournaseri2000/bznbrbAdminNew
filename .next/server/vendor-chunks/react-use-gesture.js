"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-use-gesture";
exports.ids = ["vendor-chunks/react-use-gesture"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-use-gesture/dist/react-use-gesture.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-use-gesture/dist/react-use-gesture.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addV: () => (/* binding */ addV),\n/* harmony export */   rubberbandIfOutOfBounds: () => (/* binding */ rubberbandIfOutOfBounds),\n/* harmony export */   subV: () => (/* binding */ subV),\n/* harmony export */   useDrag: () => (/* binding */ useDrag),\n/* harmony export */   useGesture: () => (/* binding */ useGesture),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useMove: () => (/* binding */ useMove),\n/* harmony export */   usePinch: () => (/* binding */ usePinch),\n/* harmony export */   useScroll: () => (/* binding */ useScroll),\n/* harmony export */   useWheel: () => (/* binding */ useWheel)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// vector add\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\nfunction calculateAllGeometry(movement, delta) {\n  if (delta === void 0) {\n    delta = movement;\n  }\n\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\nfunction calculateAllKinematics(movement, delta, dt) {\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var beta = dt === 0 ? 0 : 1 / dt;\n  var velocity = beta * dl;\n  var velocities = delta.map(function (v) {\n    return beta * v;\n  });\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    velocities: velocities,\n    velocity: velocity,\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */\n\nfunction chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {\n      var fn = _step.value;\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */\n\nfunction ensureVector(value, fallback) {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected');\n    }\n\n    value = fallback;\n  }\n\n  if (Array.isArray(value)) return value;\n  return [value, value];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */\n\nfunction valueFn(v) {\n  if (typeof v === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    // @ts-ignore\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\n\nfunction resolveWith(config, resolvers) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var result = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        resolver = _Object$entries$_i[1];\n\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar InternalGestureOptionsNormalizers = {\n  threshold: function threshold(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    return ensureVector(value);\n  },\n  rubberband: function rubberband(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND);\n\n      case false:\n        return ensureVector(0);\n\n      default:\n        return ensureVector(value);\n    }\n  },\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  initial: function initial(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    if (typeof value === 'function') return value;\n    return ensureVector(value);\n  }\n};\n\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  axis: true,\n  lockDirection: function lockDirection(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  bounds: function bounds(value) {\n    if (value === void 0) {\n      value = {};\n    }\n\n    if (typeof value === 'function') return function (state) {\n      return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n    };\n    var _value2 = value,\n        _value2$left = _value2.left,\n        left = _value2$left === void 0 ? -Infinity : _value2$left,\n        _value2$right = _value2.right,\n        right = _value2$right === void 0 ? Infinity : _value2$right,\n        _value2$top = _value2.top,\n        top = _value2$top === void 0 ? -Infinity : _value2$top,\n        _value2$bottom = _value2.bottom,\n        bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nvar InternalGenericOptionsNormalizers = {\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  domTarget: true,\n  window: /*#__PURE__*/function (_window) {\n    function window(_x) {\n      return _window.apply(this, arguments);\n    }\n\n    window.toString = function () {\n      return _window.toString();\n    };\n\n    return window;\n  }(function (value) {\n    if (value === void 0) {\n      value = isBrowser ? window : undefined;\n    }\n\n    return value;\n  }),\n  eventOptions: function eventOptions(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$passive = _ref.passive,\n        passive = _ref$passive === void 0 ? true : _ref$passive,\n        _ref$capture = _ref.capture,\n        capture = _ref$capture === void 0 ? false : _ref$capture;\n\n    return {\n      passive: passive,\n      capture: capture\n    };\n  }\n};\n\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  bounds: function bounds(_value, _key, _ref2) {\n    var _ref2$distanceBounds = _ref2.distanceBounds,\n        distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds,\n        _ref2$angleBounds = _ref2.angleBounds,\n        angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n\n    var _distanceBounds = function _distanceBounds(state) {\n      var D = assignDefault(valueFn(distanceBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(valueFn(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function') return [_distanceBounds(), _angleBounds()];\n    return function (state) {\n      return [_distanceBounds(state), _angleBounds(state)];\n    };\n  }\n});\n\nvar InternalDragOptionsNormalizers = /*#__PURE__*/_extends({}, InternalCoordinatesOptionsNormalizers, {\n  threshold: function threshold(v, _k, _ref3) {\n    var _ref3$filterTaps = _ref3.filterTaps,\n        filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps,\n        _ref3$lockDirection = _ref3.lockDirection,\n        lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection,\n        _ref3$axis = _ref3.axis,\n        axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n    var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n    this.filterTaps = filterTaps || A[0] + A[1] > 0;\n    return A;\n  },\n  swipeVelocity: function swipeVelocity(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_VELOCITY;\n    }\n\n    return ensureVector(v);\n  },\n  swipeDistance: function swipeDistance(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_DISTANCE;\n    }\n\n    return ensureVector(v);\n  },\n  delay: function delay(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n});\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith(config, InternalGenericOptionsNormalizers);\n}\nfunction getInternalCoordinatesOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\nfunction getInternalDistanceAngleOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\nfunction getInternalDragOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDragOptionsNormalizers);\n}\n\nfunction _buildMoveConfig(_ref) {\n  var domTarget = _ref.domTarget,\n      eventOptions = _ref.eventOptions,\n      window = _ref.window,\n      enabled = _ref.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.move = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction _buildHoverConfig(_ref2) {\n  var domTarget = _ref2.domTarget,\n      eventOptions = _ref2.eventOptions,\n      window = _ref2.window,\n      enabled = _ref2.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.hover = _extends({\n    enabled: true\n  }, rest);\n  return opts;\n}\nfunction _buildDragConfig(_ref3) {\n  var domTarget = _ref3.domTarget,\n      eventOptions = _ref3.eventOptions,\n      window = _ref3.window,\n      enabled = _ref3.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref3, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.drag = getInternalDragOptions(rest);\n  return opts;\n}\nfunction _buildPinchConfig(_ref4) {\n  var domTarget = _ref4.domTarget,\n      eventOptions = _ref4.eventOptions,\n      window = _ref4.window,\n      enabled = _ref4.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref4, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.pinch = getInternalDistanceAngleOptions(rest);\n  return opts;\n}\nfunction _buildScrollConfig(_ref5) {\n  var domTarget = _ref5.domTarget,\n      eventOptions = _ref5.eventOptions,\n      window = _ref5.window,\n      enabled = _ref5.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref5, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.scroll = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction _buildWheelConfig(_ref6) {\n  var domTarget = _ref6.domTarget,\n      eventOptions = _ref6.eventOptions,\n      window = _ref6.window,\n      enabled = _ref6.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref6, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.wheel = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction buildComplexConfig(config, actions) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (actions === void 0) {\n    actions = new Set();\n  }\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      domTarget = _config.domTarget,\n      enabled = _config.enabled;\n  var mergedConfig = getInternalGenericOptions({\n    eventOptions: eventOptions,\n    window: window,\n    domTarget: domTarget,\n    enabled: enabled\n  });\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag);\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move);\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  if (actions.has('onHover')) mergedConfig.hover = _extends({\n    enabled: true\n  }, hover);\n  return mergedConfig;\n}\n\nfunction getInitial(mixed) {\n  return _extends({\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }, mixed);\n}\n\nfunction getInitialState() {\n  var shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  };\n  var drag = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0,\n    _isTap: true,\n    _delayedEvent: false,\n    _pointerId: undefined,\n    tap: false,\n    swipe: [0, 0]\n  });\n  var pinch = getInitial({\n    da: [0, 0],\n    vdva: [0, 0],\n    // @ts-ignore origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0\n  });\n  var wheel = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var move = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var scroll = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  return {\n    shared: shared,\n    drag: drag,\n    pinch: pinch,\n    wheel: wheel,\n    move: move,\n    scroll: scroll\n  };\n}\n\nvar RecognizersMap = /*#__PURE__*/new Map();\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    };\n    /**\r\n     * Fires the gesture handler\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      if (forceFlag === void 0) {\n        forceFlag = false;\n      }\n\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n\n          _this.clean();\n        }\n\n        return null;\n      } // If the gesture has no intentional dimension, don't fire the handler.\n\n\n      if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n\n      if (_this.state.intentional) {\n        var prev_active = _this.state.active;\n        var next_active = _this.state._active;\n        _this.state.active = next_active;\n        _this.state.first = next_active && !prev_active;\n        _this.state.last = prev_active && !next_active;\n        _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n      }\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state)); // @ts-ignore\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_this.state._active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype;\n\n  // Convenience method to update the shared state\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Convenience method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values) {\n    var _this$config = this.config,\n        initial = _this$config.initial,\n        bounds = _this$config.bounds,\n        rubberband = _this$config.rubberband,\n        T = _this$config.threshold;\n    var _this$state = this.state,\n        _bounds = _this$state._bounds,\n        _initial = _this$state._initial,\n        _active = _this$state._active,\n        wasIntentional = _this$state._intentional,\n        lastOffset = _this$state.lastOffset,\n        prevMovement = _this$state.movement;\n    var M = this.getInternalMovement(values, this.state);\n    var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], T[0]) : wasIntentional[0];\n    var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], M);\n\n    if (intentionalityCheck._blocked) {\n      return _extends({}, intentionalityCheck, {\n        _movement: M,\n        delta: [0, 0]\n      });\n    }\n\n    var _intentional = intentionalityCheck._intentional;\n    var _movement = M;\n\n    var __cachedBounds;\n\n    var __cachedInitial;\n\n    if (_intentional[0] !== false && wasIntentional[0] === false) {\n      __cachedInitial = valueFn(initial, this.state);\n      __cachedBounds = valueFn(bounds, this.state);\n      _initial[0] = __cachedInitial[0];\n      _bounds[0] = __cachedBounds[0];\n    }\n\n    if (_intentional[1] !== false && wasIntentional[1] === false) {\n      var _cachedInitial, _cachedBounds;\n\n      __cachedInitial = (_cachedInitial = __cachedInitial) != null ? _cachedInitial : valueFn(initial, this.state);\n      __cachedBounds = (_cachedBounds = __cachedBounds) != null ? _cachedBounds : valueFn(bounds, this.state);\n      _initial[1] = __cachedInitial[1];\n      _bounds[1] = __cachedBounds[1];\n    }\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n\n    var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : _initial[0], _intentional[1] !== false ? M[1] - _intentional[1] : _initial[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n    return _extends({}, intentionalityCheck, {\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      values: values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n\n  return Recognizer;\n}(); //--------------------------------------------\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold;\n  } else {\n    return false;\n  }\n}\n\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var Vx = _ref[0],\n      Vy = _ref[1];\n  var Rx = _ref2[0],\n      Ry = _ref2[1];\n  var _bounds$ = bounds[0],\n      X1 = _bounds$[0],\n      X2 = _bounds$[1],\n      _bounds$2 = bounds[1],\n      Y1 = _bounds$2[0],\n      Y2 = _bounds$2[1];\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */\n\n\nfunction getGenericPayload(_ref3, event, isStartEvent) {\n  var state = _ref3.state,\n      args = _ref3.args;\n  var timeStamp = event.timeStamp,\n      _lastEventType = event.type;\n  var previous = state.values;\n  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n  return {\n    _lastEventType: _lastEventType,\n    event: event,\n    timeStamp: timeStamp,\n    elapsedTime: elapsedTime,\n    args: args,\n    previous: previous\n  };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */\n\nfunction getStartGestureState(recognizer, values, event) {\n  var offset = recognizer.state.offset;\n  var startTime = event.timeStamp;\n  return _extends({}, getInitialState()[recognizer.stateKey], {\n    _active: true,\n    values: values,\n    initial: values,\n    offset: offset,\n    lastOffset: offset,\n    startTime: startTime\n  });\n}\n\nfunction partial(func, state) {\n  return function (event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // @ts-ignore\n    return func.call.apply(func, [this, _extends({}, state, {\n      event: event\n    })].concat(args));\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */\n\n\nvar Controller = function Controller(classes) {\n  var _this = this;\n\n  this.classes = classes;\n\n  this.bind = function () {\n    var bindings = {};\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;) {\n      var RecognizerClass = _step.value;\n      new RecognizerClass(_this, args).addBindings(bindings);\n    } // we also add event bindings for native handlers\n\n\n    for (var _i = 0, _Object$entries = Object.entries(_this.nativeRefs); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          event = _Object$entries$_i[0],\n          handler = _Object$entries$_i[1];\n      addBindings(bindings, event, partial(handler, _extends({}, _this.state.shared, {\n        args: args\n      })));\n    }\n\n    if (_this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(_this, bindings);\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(_this, bindings);\n    }\n  };\n\n  this.effect = function () {\n    if (_this.config.domTarget) _this.bind();\n    return _this.clean;\n  };\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n\n  this.clean = function () {\n    var domTarget = getDomTargetFromConfig(_this.config);\n    var eventOptions = _this.config.eventOptions;\n    if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    clearAllWindowListeners(_this);\n  };\n\n  this.state = getInitialState();\n  this.timeouts = {};\n  this.domListeners = [];\n  this.windowListeners = {};\n};\nfunction clearAllWindowListeners(controller) {\n  var _controller$config = controller.config,\n      el = _controller$config.window,\n      eventOptions = _controller$config.eventOptions,\n      windowListeners = controller.windowListeners;\n  if (!el) return;\n\n  for (var stateKey in windowListeners) {\n    var handlers = windowListeners[stateKey];\n    removeListeners(el, handlers, eventOptions);\n  }\n\n  controller.windowListeners = {};\n}\nfunction clearWindowListeners(_ref, stateKey) {\n  var config = _ref.config,\n      windowListeners = _ref.windowListeners;\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n  delete windowListeners[stateKey];\n}\nfunction updateWindowListeners(_ref2, stateKey, listeners) {\n  var config = _ref2.config,\n      windowListeners = _ref2.windowListeners;\n\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n  addListeners(config.window, windowListeners[stateKey] = listeners, config.eventOptions);\n}\n\nfunction updateDomListeners(_ref3, bindings) {\n  var config = _ref3.config,\n      domListeners = _ref3.domListeners;\n  var domTarget = getDomTargetFromConfig(config);\n  if (!domTarget) throw new Error('domTarget must be defined');\n  var eventOptions = config.eventOptions;\n  removeListeners(domTarget, takeAll(domListeners), eventOptions);\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _Object$entries2[_i2],\n        key = _Object$entries2$_i[0],\n        fns = _Object$entries2$_i[1];\n    var name = key.slice(2).toLowerCase();\n    domListeners.push([name, chainFns.apply(void 0, fns)]);\n  }\n\n  addListeners(domTarget, domListeners, eventOptions);\n}\n\nfunction getPropsListener(_ref4, bindings) {\n  var config = _ref4.config;\n  var props = {};\n  var captureString = config.eventOptions.capture ? 'Capture' : '';\n\n  for (var _i3 = 0, _Object$entries3 = Object.entries(bindings); _i3 < _Object$entries3.length; _i3++) {\n    var _Object$entries3$_i = _Object$entries3[_i3],\n        event = _Object$entries3$_i[0],\n        fns = _Object$entries3$_i[1];\n    var fnsArray = Array.isArray(fns) ? fns : [fns];\n    var key = event + captureString;\n    props[key] = chainFns.apply(void 0, fnsArray);\n  }\n\n  return props;\n}\n\nfunction takeAll(array) {\n  if (array === void 0) {\n    array = [];\n  }\n\n  return array.splice(0, array.length);\n}\n\nfunction getDomTargetFromConfig(_ref5) {\n  var domTarget = _ref5.domTarget;\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */\n\n\nfunction addBindings(bindings, name, fn) {\n  if (!bindings[name]) bindings[name] = [];\n  bindings[name].push(fn);\n}\n\nfunction addListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;) {\n    var _step2$value = _step2.value,\n        eventName = _step2$value[0],\n        eventHandler = _step2$value[1];\n    el.addEventListener(eventName, eventHandler, options);\n  }\n}\n\nfunction removeListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;) {\n    var _step3$value = _step3.value,\n        eventName = _step3$value[0],\n        eventHandler = _step3$value[1];\n    el.removeEventListener(eventName, eventHandler, options);\n  }\n}\n\n/* eslint-disable react-hooks/exhaustive-deps */\n/**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */\n\nfunction useRecognizers(handlers, config, nativeHandlers) {\n  if (nativeHandlers === void 0) {\n    nativeHandlers = {};\n  }\n\n  var classes = resolveClasses(handlers);\n  var controller = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {\n    return new Controller(classes);\n  }, []);\n  controller.config = config;\n  controller.handlers = handlers;\n  controller.nativeRefs = nativeHandlers;\n  react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(controller.effect, []); // @ts-ignore\n\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n\n  return controller.bind;\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (true) {\n    console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n  }\n}\n\nfunction resolveClasses(internalHandlers) {\n  var classes = new Set();\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag'));\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel'));\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll'));\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move'));\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch'));\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover'));\n  return classes;\n}\n\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return {\n        _intentional: _intentional,\n        axis: this.state.axis\n      };\n    }\n\n    var _movement$map = _movement.map(Math.abs),\n        absX = _movement$map[0],\n        absY = _movement$map[1];\n\n    var axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n    if (!this.config.axis && !this.config.lockDirection) return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n    if (!axis) return {\n      _intentional: [false, false],\n      _blocked: false,\n      axis: axis\n    };\n    if (!!this.config.axis && axis !== this.config.axis) return {\n      _intentional: _intentional,\n      _blocked: true,\n      axis: axis\n    };\n    _intentional[axis === 'x' ? 1 : 0] = false;\n    return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n\n    if (!state._blocked) {\n      var dt = event.timeStamp - this.state.timeStamp;\n      Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n    }\n\n    return state;\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nfunction supportsTouchEvents() {\n  return typeof window !== 'undefined' && window.ontouchstart === null;\n}\n\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var targetTouches = event.targetTouches,\n        changedTouches = event.changedTouches;\n    return targetTouches.length > 0 ? targetTouches : changedTouches;\n  }\n\n  return null;\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n\n  return {\n    touches: touches,\n    down: down,\n    buttons: buttons,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n\n  var _ref = touchEvents ? touchEvents[0] : event,\n      clientX = _ref.clientX,\n      clientY = _ref.clientY;\n\n  return [clientX, clientY];\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return [scrollX || scrollLeft || 0, scrollY || scrollTop || 0];\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return [deltaX, deltaY];\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event) {\n  return [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation];\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\nfunction getTwoTouchesEventData(event) {\n  var _e$rotation;\n\n  var targetTouches = event.targetTouches;\n  var A = targetTouches[0],\n      B = targetTouches[1];\n  var dx = B.clientX - A.clientX;\n  var dy = B.clientY - A.clientY;\n  var cx = (B.clientX + A.clientX) / 2;\n  var cy = (B.clientY + A.clientY) / 2;\n  var e = 'nativeEvent' in event ? event.nativeEvent : event;\n  var distance = Math.hypot(dx, dy);\n  var angle = (_e$rotation = e.rotation) != null ? _e$rotation : -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var values = [distance, angle];\n  var origin = [cx, cy];\n  return {\n    values: values,\n    origin: origin\n  };\n}\n\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'dragging';\n    _this.stateKey = 'drag';\n    /**\r\n     * TODO add back when setPointerCapture is widely wupported\r\n     * https://caniuse.com/#search=setPointerCapture\r\n     * private setPointers = (event: UseGestureEvent<PointerEvent>) => {\r\n     *   const { currentTarget, pointerId } = event\r\n     *   if (currentTarget) currentTarget.setPointerCapture(pointerId)\r\n     *   this.updateGestureState({ currentTarget, pointerId })\r\n     * }\r\n            * private removePointers = () => {\r\n     *   const { currentTarget, pointerId } = this.state\r\n     *   if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\r\n     * }\r\n     */\n\n    _this.onDragStart = function (event) {\n      if (!_this.enabled || _this.state._active) return;\n      /**\r\n       * TODO add back when setPointerCapture is widely supported\r\n       * this.setPointers(event as PointerEvent)\r\n       */\n\n      updateWindowListeners(_this.controller, _this.stateKey, [['pointermove', _this.onDragChange], ['pointerup', _this.onDragEnd], ['pointercancel', _this.onDragEnd]]); // We set the state pointerId to the event.pointerId so we can make sure\n      // that we lock the drag to the event initiating the gesture\n\n      _this.updateGestureState({\n        _pointerId: event.pointerId\n      });\n\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true; // If it's a React SyntheticEvent we need to persist it so that we can use it async\n\n        if ('persist' in event && typeof event.persist === 'function') event.persist();\n\n        _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n\n    _this.onDragChange = function (event) {\n      // If the gesture was canceled don't respond to the event.\n      if (_this.state.canceled) return; // If the event pointerId doesn't match the initiating pointerId\n      // don't respond to the event.\n\n      if (event.pointerId !== _this.state._pointerId) return; // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n\n          _this.startDrag(event);\n        }\n\n        return;\n      }\n\n      var genericEventData = getGenericEventData(event); // If the event doesn't have any button / touches left we should cancel\n      // the gesture. This may happen if the drag release happens outside the browser\n      // window.\n\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n\n        return;\n      }\n\n      _this.updateSharedState(genericEventData);\n\n      var values = getPointerEventValues(event);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n      // if the real distance of the drag (ie not accounting for the threshold) is\n      // greater than the TAP_DISTANCE_THRESHOLD.\n\n      var _isTap = _this.state._isTap;\n      var realDistance = calculateDistance(kinematics._movement);\n      if (_isTap && realDistance >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n\n      _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n        _isTap: _isTap\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      // If the event pointerId doesn't match the initiating pointerId\n      // don't respond to the event.\n      if (event.pointerId !== _this.state._pointerId) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      var tap = _this.state._isTap;\n      var _this$state$velocitie = _this.state.velocities,\n          vx = _this$state$velocitie[0],\n          vy = _this$state$velocitie[1];\n      var _this$state$movement = _this.state.movement,\n          mx = _this$state$movement[0],\n          my = _this$state$movement[1];\n      var _this$state$_intentio = _this.state._intentional,\n          ix = _this$state$_intentio[0],\n          iy = _this$state$_intentio[1];\n      var _this$config$swipeVel = _this.config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1];\n      var _this$config$swipeDis = _this.config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n\n      var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n\n      var swipe = [0, 0];\n\n      if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n\n      _this.updateGestureState(_extends({}, endState, {\n        tap: tap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(tap === true);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._delayedEvent = false; // can't remember if this is useful?\n\n      clearWindowListeners(_this.controller, _this.stateKey); // TODO add back when setPointerCapture is widely wupported\n      // this.removePointers()\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n\n      _this.updateGestureState({\n        canceled: true\n      });\n\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n\n    _this.onClick = function (event) {\n      if (!_this.state._isTap) event.stopPropagation();\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event) {\n    var values = getPointerEventValues(event);\n    this.updateSharedState(getGenericEventData(event));\n    this.updateGestureState(_extends({}, getStartGestureState(this, values, event), getGenericPayload(this, event, true), {\n      _pointerId: event.pointerId,\n      cancel: this.onCancel\n    }));\n    this.updateGestureState(this.getMovement(values));\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onPointerDown', this.onDragStart);\n\n    if (this.config.filterTaps) {\n      var handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture';\n\n      addBindings(bindings, handler, this.onClick);\n    } // TODO add back when setPointerCapture is widely wupported\n    // addBindings(bindings, 'onPointerMove', this.onDragChange)\n    // addBindings(bindings, 'onPointerUp', this.onDragEnd)\n    // addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */\nfunction memoizeOne(resultFn, isEqual) {\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  function memoized() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n\n  return memoized;\n}\n\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */\nfunction equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    var it;\n\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      }\n\n      return true;\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) continue;\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nfunction isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n\n    throw error;\n  }\n}\n\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('drag', DragRecognizer);\n  var buildDragConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n  }\n\n  return useRecognizers({\n    drag: handler\n  }, buildDragConfig.current(config));\n}\n\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n\n    var d = values[0],\n        _values$ = values[1],\n        a = _values$ === void 0 ? prev_a : _values$;\n    var delta_a = a - prev_a;\n    var next_turns = state.turns;\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n    return subV([d, a - 360 * next_turns], state.initial);\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    var turns = (values[1] - state.movement[1] - this.state.initial[1]) / 360;\n    var dt = event.timeStamp - this.state.timeStamp;\n    var kinematics = calculateAllKinematics(state.movement, state.delta, dt);\n    return _extends({\n      turns: turns\n    }, state, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer() {\n    var _this;\n\n    _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n    _this.ingKey = 'pinching';\n    _this.stateKey = 'pinch';\n\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      return _this.enabled && touches === 2;\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        cancel: _this.onCancel,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin; // @ts-ignore\n\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: origin\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchEnd = function (event) {\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n      _this.state._active = false;\n\n      _this.updateGestureState({\n        canceled: true\n      });\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault(); // useless\n\n      var values = getWebkitGestureEventValues(event);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        origin: [event.clientX, event.clientY],\n        cancel: _this.onCancel\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var values = getWebkitGestureEventValues(event);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n          delta_d = _getWheelEventValues[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (event.cancelable) event.preventDefault();else if (true) {\n        console.warn('To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        initial: _this.state.values,\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !supportsTouchEvents() && supportsGestureEvents()) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart);\n\n      addBindings(bindings, 'onGestureChange', this.onGestureChange);\n\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd);\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart);\n\n      addBindings(bindings, 'onTouchMove', this.onPinchChange);\n\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd);\n\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd);\n\n      addBindings(bindings, 'onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('pinch', PinchRecognizer);\n  var buildPinchConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n  }\n\n  return useRecognizers({\n    pinch: handler\n  }, buildPinchConfig.current(config));\n}\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'wheeling';\n    _this.stateKey = 'wheel';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return;\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onEnd);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = addV(getWheelEventValues(event), _this.state.values);\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movement = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movement.delta);\n\n        _this.updateGestureState(movement);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      var movement = _this.getMovement(_this.state.values);\n\n      _this.updateGestureState(movement);\n\n      _this.updateGestureState({\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onWheel', this.handleEvent);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var buildWheelConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n  }\n\n  return useRecognizers({\n    wheel: handler\n  }, buildWheelConfig.current(config));\n}\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'moving';\n    _this.stateKey = 'move';\n    _this.debounced = true;\n\n    _this.onMove = function (event) {\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event);\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      var values = _this.state.values;\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.updateGestureState({\n        velocities: [0, 0],\n        velocity: 0,\n        _active: false\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var values = getPointerEventValues(event);\n\n        var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (!_this.controller.config.hover.enabled) return;\n      var values = getPointerEventValues(event);\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n        values: values,\n        active: false\n      });\n\n      _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove);\n    }\n\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter);\n\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave);\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('move', MoveRecognizer);\n  var buildMoveConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n  }\n\n  return useRecognizers({\n    move: handler\n  }, buildMoveConfig.current(config));\n}\n\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('hover', MoveRecognizer);\n  var buildHoverConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n  }\n\n  return useRecognizers({\n    hover: handler\n  }, buildHoverConfig.current(config));\n}\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'scrolling';\n    _this.stateKey = 'scroll';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (!_this.enabled) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var values = getScrollEventValues(event);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movementDetection = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movementDetection.delta);\n\n        _this.updateGestureState(movementDetection);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onScroll', this.handleEvent);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  var buildScrollConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n  }\n\n  return useRecognizers({\n    scroll: handler\n  }, buildScrollConfig.current(config));\n}\n\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(handlers) {\n  var _native = {};\n  var handle = {};\n  var actions = new Set();\n\n  for (var key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handle[key] = handlers[key];\n    } else {\n      _native[key] = handlers[key];\n    }\n  }\n\n  return [handle, _native, actions];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(_handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _sortHandlers = sortHandlers(_handlers),\n      handlers = _sortHandlers[0],\n      nativeHandlers = _sortHandlers[1],\n      actions = _sortHandlers[2];\n\n  RecognizersMap.set('drag', DragRecognizer);\n  RecognizersMap.set('hover', MoveRecognizer);\n  RecognizersMap.set('move', MoveRecognizer);\n  RecognizersMap.set('pinch', PinchRecognizer);\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var mergedConfig = buildComplexConfig(config, actions);\n  var internalHandlers = {};\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag');\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel');\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll');\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove');\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch');\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover;\n  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\n\nfunction includeStartEndHandlers(handlers, handlerKey) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\n\n//# sourceMappingURL=react-use-gesture.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdXNlLWdlc3R1cmUvZGlzdC9yZWFjdC11c2UtZ2VzdHVyZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsd0JBQXdCO0FBQzFCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFLDRCQUE0QjtBQUNsRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0VBQWdFLDZCQUE2QjtBQUM3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCwwQ0FBMEM7QUFDMUM7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxTQUFTLElBQXNDO0FBQ2xHO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsa0JBQWtCLFVBQVU7QUFDdkMsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFc0g7QUFDdEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZXphbmltLWJpcm9vbi8uL25vZGVfbW9kdWxlcy9yZWFjdC11c2UtZ2VzdHVyZS9kaXN0L3JlYWN0LXVzZS1nZXN0dXJlLmVzbS5qcz8xOTRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbi8vIHZlY3RvciBhZGRcbmZ1bmN0aW9uIGFkZFYodjEsIHYyKSB7XG4gIHJldHVybiB2MS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICByZXR1cm4gdiArIHYyW2ldO1xuICB9KTtcbn0gLy8gdmVjdG9yIHN1YnN0cmFjdFxuXG5mdW5jdGlvbiBzdWJWKHYxLCB2Mikge1xuICByZXR1cm4gdjEubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgcmV0dXJuIHYgLSB2MltpXTtcbiAgfSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBkaXN0YW5jZVxyXG4gKiBAcGFyYW0gbW92ZW1lbnQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBpbml0aWFsIHZlY3RvcnNcclxuICogQHJldHVybnMgZGlzdGFuY2VcclxuICovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKG1vdmVtZW50KSB7XG4gIHJldHVybiBNYXRoLmh5cG90LmFwcGx5KE1hdGgsIG1vdmVtZW50KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFsbEdlb21ldHJ5KG1vdmVtZW50LCBkZWx0YSkge1xuICBpZiAoZGVsdGEgPT09IHZvaWQgMCkge1xuICAgIGRlbHRhID0gbW92ZW1lbnQ7XG4gIH1cblxuICB2YXIgZGwgPSBjYWxjdWxhdGVEaXN0YW5jZShkZWx0YSk7XG4gIHZhciBhbHBoYSA9IGRsID09PSAwID8gMCA6IDEgLyBkbDtcbiAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBhbHBoYSAqIHY7XG4gIH0pO1xuICB2YXIgZGlzdGFuY2UgPSBjYWxjdWxhdGVEaXN0YW5jZShtb3ZlbWVudCk7XG4gIHJldHVybiB7XG4gICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gIH07XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhbGwga2luZW1hdGljc1xyXG4gKiBAdGVtcGxhdGUgVCB0aGUgZXhwZWN0ZWQgdmVjdG9yIHR5cGVcclxuICogQHBhcmFtIG1vdmVtZW50IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgaW5pdGlhbCB2ZWN0b3JzXHJcbiAqIEBwYXJhbSBkZWx0YSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIHByZXZpb3VzIHZlY3RvcnNcclxuICogQHBhcmFtIGRlbHRhX3QgdGhlIHRpbWUgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIHByZXZpb3VzIHRpbWVzdGFtcHNcclxuICogQHJldHVybnMgYWxsIGtpbmVtYXRpY3NcclxuICovXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFsbEtpbmVtYXRpY3MobW92ZW1lbnQsIGRlbHRhLCBkdCkge1xuICB2YXIgZGwgPSBjYWxjdWxhdGVEaXN0YW5jZShkZWx0YSk7XG4gIHZhciBhbHBoYSA9IGRsID09PSAwID8gMCA6IDEgLyBkbDtcbiAgdmFyIGJldGEgPSBkdCA9PT0gMCA/IDAgOiAxIC8gZHQ7XG4gIHZhciB2ZWxvY2l0eSA9IGJldGEgKiBkbDtcbiAgdmFyIHZlbG9jaXRpZXMgPSBkZWx0YS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gYmV0YSAqIHY7XG4gIH0pO1xuICB2YXIgZGlyZWN0aW9uID0gZGVsdGEubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGFscGhhICogdjtcbiAgfSk7XG4gIHZhciBkaXN0YW5jZSA9IGNhbGN1bGF0ZURpc3RhbmNlKG1vdmVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB2ZWxvY2l0aWVzOiB2ZWxvY2l0aWVzLFxuICAgIHZlbG9jaXR5OiB2ZWxvY2l0eSxcbiAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgfTtcbn1cbi8qKlxyXG4gKiBCZWNhdXNlIElFIGRvZXNuJ3Qgc3VwcG9ydCBgTWF0aC5zaWduYCBmdW5jdGlvbiwgc28gd2UgdXNlIHRoZSBwb2x5ZmlsbCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbi5cclxuICogVGhpcyBwb2x5ZmlsbCBmdW5jdGlvbiBpcyBzdWdnZXN0ZWQgYnkgTW96aWxsYTpcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduI1BvbHlmaWxsXHJcbiAqIEBwYXJhbSB4IHRhcmdldCBudW1iZXJcclxuICovXG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICBpZiAoTWF0aC5zaWduKSByZXR1cm4gTWF0aC5zaWduKHgpO1xuICByZXR1cm4gTnVtYmVyKHggPiAwKSAtIE51bWJlcih4IDwgMCkgfHwgK3g7XG59XG5cbmZ1bmN0aW9uIG1pbk1heCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xufSAvLyBCYXNlZCBvbiBAYWhvbGFjaGVrIDspXG4vLyBodHRwczovL3R3aXR0ZXIuY29tL2NocHduL3N0YXR1cy8yODU1NDAxOTIwOTY0OTc2NjRcbi8vIGlPUyBjb25zdGFudCA9IDAuNTVcbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AbmF0aGFuZ2l0dGVyL2J1aWxkaW5nLWZsdWlkLWludGVyZmFjZXMtaW9zLXN3aWZ0LTk3MzJiYjkzNGJmNVxuXG5cbmZ1bmN0aW9uIHJ1YmJlcmJhbmQyKGRpc3RhbmNlLCBjb25zdGFudCkge1xuICAvLyBkZWZhdWx0IGNvbnN0YW50IGZyb20gdGhlIGFydGljbGUgaXMgMC43XG4gIHJldHVybiBNYXRoLnBvdyhkaXN0YW5jZSwgY29uc3RhbnQgKiA1KTtcbn1cblxuZnVuY3Rpb24gcnViYmVyYmFuZChkaXN0YW5jZSwgZGltZW5zaW9uLCBjb25zdGFudCkge1xuICBpZiAoZGltZW5zaW9uID09PSAwIHx8IE1hdGguYWJzKGRpbWVuc2lvbikgPT09IEluZmluaXR5KSByZXR1cm4gcnViYmVyYmFuZDIoZGlzdGFuY2UsIGNvbnN0YW50KTtcbiAgcmV0dXJuIGRpc3RhbmNlICogZGltZW5zaW9uICogY29uc3RhbnQgLyAoZGltZW5zaW9uICsgY29uc3RhbnQgKiBkaXN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzKHBvc2l0aW9uLCBtaW4sIG1heCwgY29uc3RhbnQpIHtcbiAgaWYgKGNvbnN0YW50ID09PSB2b2lkIDApIHtcbiAgICBjb25zdGFudCA9IDAuMTU7XG4gIH1cblxuICBpZiAoY29uc3RhbnQgPT09IDApIHJldHVybiBtaW5NYXgocG9zaXRpb24sIG1pbiwgbWF4KTtcbiAgaWYgKHBvc2l0aW9uIDwgbWluKSByZXR1cm4gLXJ1YmJlcmJhbmQobWluIC0gcG9zaXRpb24sIG1heCAtIG1pbiwgY29uc3RhbnQpICsgbWluO1xuICBpZiAocG9zaXRpb24gPiBtYXgpIHJldHVybiArcnViYmVyYmFuZChwb3NpdGlvbiAtIG1heCwgbWF4IC0gbWluLCBjb25zdGFudCkgKyBtYXg7XG4gIHJldHVybiBwb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBpdC5uZXh0LmJpbmQoaXQpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxyXG4gKiBUT0RPIEJld2FyZSB0aGF0IG9ubHkgb3B0aW1pemVkIGNhc2VzIGFyZSBjb3ZlcmVkIGluIHRlc3RzID0pXHJcbiAqIFRPRE8gTmVlZCB0byBjb3ZlciBnZW5lcmFsIGNhc2UgYXMgd2VsbFxyXG4gKlxyXG4gKiBAcGFyYW0gZm5zXHJcbiAqL1xuXG5mdW5jdGlvbiBjaGFpbkZucygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5vb3A7XG4gIGlmIChmbnMubGVuZ3RoID09PSAxKSByZXR1cm4gZm5zWzBdO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGZucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZm4gPSBfc3RlcC52YWx1ZTtcbiAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG4vKipcclxuICogRXhwZWN0cyBhIHNpbXBsZSB2YWx1ZSBvciAyRCB2ZWN0b3IgKGFuIGFycmF5IHdpdGggMiBlbGVtZW50cykgYW5kXHJcbiAqIGFsd2F5cyByZXR1cm5zIDJEIHZlY3Rvci4gSWYgc2ltcGxlIHZhbHVlIGlzIHBhc3NlZCwgcmV0dXJucyBhXHJcbiAqIHZlY3RvciB3aXRoIHRoaXMgdmFsdWUgYXMgYm90aCBjb29yZGluYXRlcy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBlbnN1cmVWZWN0b3IodmFsdWUsIGZhbGxiYWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBkZWZpbmUgZmFsbGJhY2sgdmFsdWUgaWYgdW5kZWZpbmVkIGlzIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICByZXR1cm4gW3ZhbHVlLCB2YWx1ZV07XG59XG4vKipcclxuICogSGVscGVyIGZvciBkZWZpbmluZyBhIGRlZmF1bHQgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEBwYXJhbSBmYWxsYmFja1xyXG4gKi9cblxuZnVuY3Rpb24gYXNzaWduRGVmYXVsdCh2YWx1ZSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGZhbGxiYWNrLCB2YWx1ZSB8fCB7fSk7XG59XG4vKipcclxuICogUmVzb2x2ZXMgZ2V0dGVycyAoZnVuY3Rpb25zKSBieSBjYWxsaW5nIHRoZW1cclxuICogSWYgc2ltcGxlIHZhbHVlIGlzIGdpdmVuIGl0IGp1c3QgcGFzc2VzIHRocm91Z2hcclxuICpcclxuICogQHBhcmFtIHZcclxuICovXG5cbmZ1bmN0aW9uIHZhbHVlRm4odikge1xuICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHYuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlV2l0aChjb25maWcsIHJlc29sdmVycykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJlc29sdmVycyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfT2JqZWN0JGVudHJpZXMkX2kgPSBfT2JqZWN0JGVudHJpZXNbX2ldLFxuICAgICAgICBrZXkgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sXG4gICAgICAgIHJlc29sdmVyID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgcmVzb2x2ZXIpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgcmVzdWx0W2tleV0gPSByZXNvbHZlci5jYWxsKHJlc3VsdCwgY29uZmlnW2tleV0sIGtleSwgY29uZmlnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJlc3VsdFtrZXldID0gcmVzb2x2ZVdpdGgoY29uZmlnW2tleV0sIHJlc29sdmVyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAocmVzb2x2ZXIpIHJlc3VsdFtrZXldID0gY29uZmlnW2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBERUZBVUxUX0RSQUdfREVMQVkgPSAxODA7XG52YXIgREVGQVVMVF9SVUJCRVJCQU5EID0gMC4xNTtcbnZhciBERUZBVUxUX1NXSVBFX1ZFTE9DSVRZID0gMC41O1xudmFyIERFRkFVTFRfU1dJUEVfRElTVEFOQ0UgPSA2MDtcbnZhciBJbnRlcm5hbEdlc3R1cmVPcHRpb25zTm9ybWFsaXplcnMgPSB7XG4gIHRocmVzaG9sZDogZnVuY3Rpb24gdGhyZXNob2xkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5zdXJlVmVjdG9yKHZhbHVlKTtcbiAgfSxcbiAgcnViYmVyYmFuZDogZnVuY3Rpb24gcnViYmVyYmFuZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuXG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gZW5zdXJlVmVjdG9yKERFRkFVTFRfUlVCQkVSQkFORCk7XG5cbiAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIHJldHVybiBlbnN1cmVWZWN0b3IoMCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlbnN1cmVWZWN0b3IodmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgZW5hYmxlZDogZnVuY3Rpb24gZW5hYmxlZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0cmlnZ2VyQWxsRXZlbnRzOiBmdW5jdGlvbiB0cmlnZ2VyQWxsRXZlbnRzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBpbml0aWFsOiBmdW5jdGlvbiBpbml0aWFsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIGVuc3VyZVZlY3Rvcih2YWx1ZSk7XG4gIH1cbn07XG5cbnZhciBJbnRlcm5hbENvb3JkaW5hdGVzT3B0aW9uc05vcm1hbGl6ZXJzID0gLyojX19QVVJFX18qL19leHRlbmRzKHt9LCBJbnRlcm5hbEdlc3R1cmVPcHRpb25zTm9ybWFsaXplcnMsIHtcbiAgYXhpczogdHJ1ZSxcbiAgbG9ja0RpcmVjdGlvbjogZnVuY3Rpb24gbG9ja0RpcmVjdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgYm91bmRzOiBmdW5jdGlvbiBib3VuZHModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gSW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnNOb3JtYWxpemVycy5ib3VuZHModmFsdWUoc3RhdGUpKTtcbiAgICB9O1xuICAgIHZhciBfdmFsdWUyID0gdmFsdWUsXG4gICAgICAgIF92YWx1ZTIkbGVmdCA9IF92YWx1ZTIubGVmdCxcbiAgICAgICAgbGVmdCA9IF92YWx1ZTIkbGVmdCA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX3ZhbHVlMiRsZWZ0LFxuICAgICAgICBfdmFsdWUyJHJpZ2h0ID0gX3ZhbHVlMi5yaWdodCxcbiAgICAgICAgcmlnaHQgPSBfdmFsdWUyJHJpZ2h0ID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF92YWx1ZTIkcmlnaHQsXG4gICAgICAgIF92YWx1ZTIkdG9wID0gX3ZhbHVlMi50b3AsXG4gICAgICAgIHRvcCA9IF92YWx1ZTIkdG9wID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfdmFsdWUyJHRvcCxcbiAgICAgICAgX3ZhbHVlMiRib3R0b20gPSBfdmFsdWUyLmJvdHRvbSxcbiAgICAgICAgYm90dG9tID0gX3ZhbHVlMiRib3R0b20gPT09IHZvaWQgMCA/IEluZmluaXR5IDogX3ZhbHVlMiRib3R0b207XG4gICAgcmV0dXJuIFtbbGVmdCwgcmlnaHRdLCBbdG9wLCBib3R0b21dXTtcbiAgfVxufSk7XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgSW50ZXJuYWxHZW5lcmljT3B0aW9uc05vcm1hbGl6ZXJzID0ge1xuICBlbmFibGVkOiBmdW5jdGlvbiBlbmFibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGRvbVRhcmdldDogdHJ1ZSxcbiAgd2luZG93OiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF93aW5kb3cpIHtcbiAgICBmdW5jdGlvbiB3aW5kb3coX3gpIHtcbiAgICAgIHJldHVybiBfd2luZG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgd2luZG93LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF93aW5kb3cudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBpc0Jyb3dzZXIgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KSxcbiAgZXZlbnRPcHRpb25zOiBmdW5jdGlvbiBldmVudE9wdGlvbnMoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJHBhc3NpdmUgPSBfcmVmLnBhc3NpdmUsXG4gICAgICAgIHBhc3NpdmUgPSBfcmVmJHBhc3NpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHBhc3NpdmUsXG4gICAgICAgIF9yZWYkY2FwdHVyZSA9IF9yZWYuY2FwdHVyZSxcbiAgICAgICAgY2FwdHVyZSA9IF9yZWYkY2FwdHVyZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGNhcHR1cmU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFzc2l2ZTogcGFzc2l2ZSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgICB9O1xuICB9XG59O1xuXG52YXIgSW50ZXJuYWxEaXN0YW5jZUFuZ2xlT3B0aW9uc05vcm1hbGl6ZXJzID0gLyojX19QVVJFX18qL19leHRlbmRzKHt9LCBJbnRlcm5hbEdlc3R1cmVPcHRpb25zTm9ybWFsaXplcnMsIHtcbiAgYm91bmRzOiBmdW5jdGlvbiBib3VuZHMoX3ZhbHVlLCBfa2V5LCBfcmVmMikge1xuICAgIHZhciBfcmVmMiRkaXN0YW5jZUJvdW5kcyA9IF9yZWYyLmRpc3RhbmNlQm91bmRzLFxuICAgICAgICBkaXN0YW5jZUJvdW5kcyA9IF9yZWYyJGRpc3RhbmNlQm91bmRzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYyJGRpc3RhbmNlQm91bmRzLFxuICAgICAgICBfcmVmMiRhbmdsZUJvdW5kcyA9IF9yZWYyLmFuZ2xlQm91bmRzLFxuICAgICAgICBhbmdsZUJvdW5kcyA9IF9yZWYyJGFuZ2xlQm91bmRzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYyJGFuZ2xlQm91bmRzO1xuXG4gICAgdmFyIF9kaXN0YW5jZUJvdW5kcyA9IGZ1bmN0aW9uIF9kaXN0YW5jZUJvdW5kcyhzdGF0ZSkge1xuICAgICAgdmFyIEQgPSBhc3NpZ25EZWZhdWx0KHZhbHVlRm4oZGlzdGFuY2VCb3VuZHMsIHN0YXRlKSwge1xuICAgICAgICBtaW46IC1JbmZpbml0eSxcbiAgICAgICAgbWF4OiBJbmZpbml0eVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW0QubWluLCBELm1heF07XG4gICAgfTtcblxuICAgIHZhciBfYW5nbGVCb3VuZHMgPSBmdW5jdGlvbiBfYW5nbGVCb3VuZHMoc3RhdGUpIHtcbiAgICAgIHZhciBBID0gYXNzaWduRGVmYXVsdCh2YWx1ZUZuKGFuZ2xlQm91bmRzLCBzdGF0ZSksIHtcbiAgICAgICAgbWluOiAtSW5maW5pdHksXG4gICAgICAgIG1heDogSW5maW5pdHlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtBLm1pbiwgQS5tYXhdO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGRpc3RhbmNlQm91bmRzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhbmdsZUJvdW5kcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIFtfZGlzdGFuY2VCb3VuZHMoKSwgX2FuZ2xlQm91bmRzKCldO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBbX2Rpc3RhbmNlQm91bmRzKHN0YXRlKSwgX2FuZ2xlQm91bmRzKHN0YXRlKV07XG4gICAgfTtcbiAgfVxufSk7XG5cbnZhciBJbnRlcm5hbERyYWdPcHRpb25zTm9ybWFsaXplcnMgPSAvKiNfX1BVUkVfXyovX2V4dGVuZHMoe30sIEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zTm9ybWFsaXplcnMsIHtcbiAgdGhyZXNob2xkOiBmdW5jdGlvbiB0aHJlc2hvbGQodiwgX2ssIF9yZWYzKSB7XG4gICAgdmFyIF9yZWYzJGZpbHRlclRhcHMgPSBfcmVmMy5maWx0ZXJUYXBzLFxuICAgICAgICBmaWx0ZXJUYXBzID0gX3JlZjMkZmlsdGVyVGFwcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRmaWx0ZXJUYXBzLFxuICAgICAgICBfcmVmMyRsb2NrRGlyZWN0aW9uID0gX3JlZjMubG9ja0RpcmVjdGlvbixcbiAgICAgICAgbG9ja0RpcmVjdGlvbiA9IF9yZWYzJGxvY2tEaXJlY3Rpb24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjMkbG9ja0RpcmVjdGlvbixcbiAgICAgICAgX3JlZjMkYXhpcyA9IF9yZWYzLmF4aXMsXG4gICAgICAgIGF4aXMgPSBfcmVmMyRheGlzID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmMyRheGlzO1xuICAgIHZhciBBID0gZW5zdXJlVmVjdG9yKHYsIGZpbHRlclRhcHMgPyAzIDogbG9ja0RpcmVjdGlvbiA/IDEgOiBheGlzID8gMSA6IDApO1xuICAgIHRoaXMuZmlsdGVyVGFwcyA9IGZpbHRlclRhcHMgfHwgQVswXSArIEFbMV0gPiAwO1xuICAgIHJldHVybiBBO1xuICB9LFxuICBzd2lwZVZlbG9jaXR5OiBmdW5jdGlvbiBzd2lwZVZlbG9jaXR5KHYpIHtcbiAgICBpZiAodiA9PT0gdm9pZCAwKSB7XG4gICAgICB2ID0gREVGQVVMVF9TV0lQRV9WRUxPQ0lUWTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5zdXJlVmVjdG9yKHYpO1xuICB9LFxuICBzd2lwZURpc3RhbmNlOiBmdW5jdGlvbiBzd2lwZURpc3RhbmNlKHYpIHtcbiAgICBpZiAodiA9PT0gdm9pZCAwKSB7XG4gICAgICB2ID0gREVGQVVMVF9TV0lQRV9ESVNUQU5DRTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5zdXJlVmVjdG9yKHYpO1xuICB9LFxuICBkZWxheTogZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfRFJBR19ERUxBWTtcblxuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zKGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIC8vIFRPRE8gd2FybiB3aGVuIHBhc3NpdmUgaXMgc2V0IHRvIHRydWUgYW5kIGRvbVRhcmdldCBpcyB1bmRlZmluZWRcbiAgcmV0dXJuIHJlc29sdmVXaXRoKGNvbmZpZywgSW50ZXJuYWxHZW5lcmljT3B0aW9uc05vcm1hbGl6ZXJzKTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zKGNvbmZpZykge1xuICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlV2l0aChjb25maWcsIEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zTm9ybWFsaXplcnMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxEaXN0YW5jZUFuZ2xlT3B0aW9ucyhjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICByZXR1cm4gcmVzb2x2ZVdpdGgoY29uZmlnLCBJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zTm9ybWFsaXplcnMpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxEcmFnT3B0aW9ucyhjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICByZXR1cm4gcmVzb2x2ZVdpdGgoY29uZmlnLCBJbnRlcm5hbERyYWdPcHRpb25zTm9ybWFsaXplcnMpO1xufVxuXG5mdW5jdGlvbiBfYnVpbGRNb3ZlQ29uZmlnKF9yZWYpIHtcbiAgdmFyIGRvbVRhcmdldCA9IF9yZWYuZG9tVGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zID0gX3JlZi5ldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3cgPSBfcmVmLndpbmRvdyxcbiAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiZG9tVGFyZ2V0XCIsIFwiZXZlbnRPcHRpb25zXCIsIFwid2luZG93XCIsIFwiZW5hYmxlZFwiXSk7XG5cbiAgdmFyIG9wdHMgPSBnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zKHtcbiAgICBkb21UYXJnZXQ6IGRvbVRhcmdldCxcbiAgICBldmVudE9wdGlvbnM6IGV2ZW50T3B0aW9ucyxcbiAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICBlbmFibGVkOiBlbmFibGVkXG4gIH0pO1xuICBvcHRzLm1vdmUgPSBnZXRJbnRlcm5hbENvb3JkaW5hdGVzT3B0aW9ucyhyZXN0KTtcbiAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBfYnVpbGRIb3ZlckNvbmZpZyhfcmVmMikge1xuICB2YXIgZG9tVGFyZ2V0ID0gX3JlZjIuZG9tVGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zID0gX3JlZjIuZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93ID0gX3JlZjIud2luZG93LFxuICAgICAgZW5hYmxlZCA9IF9yZWYyLmVuYWJsZWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjIsIFtcImRvbVRhcmdldFwiLCBcImV2ZW50T3B0aW9uc1wiLCBcIndpbmRvd1wiLCBcImVuYWJsZWRcIl0pO1xuXG4gIHZhciBvcHRzID0gZ2V0SW50ZXJuYWxHZW5lcmljT3B0aW9ucyh7XG4gICAgZG9tVGFyZ2V0OiBkb21UYXJnZXQsXG4gICAgZXZlbnRPcHRpb25zOiBldmVudE9wdGlvbnMsXG4gICAgd2luZG93OiB3aW5kb3csXG4gICAgZW5hYmxlZDogZW5hYmxlZFxuICB9KTtcbiAgb3B0cy5ob3ZlciA9IF9leHRlbmRzKHtcbiAgICBlbmFibGVkOiB0cnVlXG4gIH0sIHJlc3QpO1xuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIF9idWlsZERyYWdDb25maWcoX3JlZjMpIHtcbiAgdmFyIGRvbVRhcmdldCA9IF9yZWYzLmRvbVRhcmdldCxcbiAgICAgIGV2ZW50T3B0aW9ucyA9IF9yZWYzLmV2ZW50T3B0aW9ucyxcbiAgICAgIHdpbmRvdyA9IF9yZWYzLndpbmRvdyxcbiAgICAgIGVuYWJsZWQgPSBfcmVmMy5lbmFibGVkLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYzLCBbXCJkb21UYXJnZXRcIiwgXCJldmVudE9wdGlvbnNcIiwgXCJ3aW5kb3dcIiwgXCJlbmFibGVkXCJdKTtcblxuICB2YXIgb3B0cyA9IGdldEludGVybmFsR2VuZXJpY09wdGlvbnMoe1xuICAgIGRvbVRhcmdldDogZG9tVGFyZ2V0LFxuICAgIGV2ZW50T3B0aW9uczogZXZlbnRPcHRpb25zLFxuICAgIHdpbmRvdzogd2luZG93LFxuICAgIGVuYWJsZWQ6IGVuYWJsZWRcbiAgfSk7XG4gIG9wdHMuZHJhZyA9IGdldEludGVybmFsRHJhZ09wdGlvbnMocmVzdCk7XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gX2J1aWxkUGluY2hDb25maWcoX3JlZjQpIHtcbiAgdmFyIGRvbVRhcmdldCA9IF9yZWY0LmRvbVRhcmdldCxcbiAgICAgIGV2ZW50T3B0aW9ucyA9IF9yZWY0LmV2ZW50T3B0aW9ucyxcbiAgICAgIHdpbmRvdyA9IF9yZWY0LndpbmRvdyxcbiAgICAgIGVuYWJsZWQgPSBfcmVmNC5lbmFibGVkLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY0LCBbXCJkb21UYXJnZXRcIiwgXCJldmVudE9wdGlvbnNcIiwgXCJ3aW5kb3dcIiwgXCJlbmFibGVkXCJdKTtcblxuICB2YXIgb3B0cyA9IGdldEludGVybmFsR2VuZXJpY09wdGlvbnMoe1xuICAgIGRvbVRhcmdldDogZG9tVGFyZ2V0LFxuICAgIGV2ZW50T3B0aW9uczogZXZlbnRPcHRpb25zLFxuICAgIHdpbmRvdzogd2luZG93LFxuICAgIGVuYWJsZWQ6IGVuYWJsZWRcbiAgfSk7XG4gIG9wdHMucGluY2ggPSBnZXRJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zKHJlc3QpO1xuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIF9idWlsZFNjcm9sbENvbmZpZyhfcmVmNSkge1xuICB2YXIgZG9tVGFyZ2V0ID0gX3JlZjUuZG9tVGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zID0gX3JlZjUuZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93ID0gX3JlZjUud2luZG93LFxuICAgICAgZW5hYmxlZCA9IF9yZWY1LmVuYWJsZWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjUsIFtcImRvbVRhcmdldFwiLCBcImV2ZW50T3B0aW9uc1wiLCBcIndpbmRvd1wiLCBcImVuYWJsZWRcIl0pO1xuXG4gIHZhciBvcHRzID0gZ2V0SW50ZXJuYWxHZW5lcmljT3B0aW9ucyh7XG4gICAgZG9tVGFyZ2V0OiBkb21UYXJnZXQsXG4gICAgZXZlbnRPcHRpb25zOiBldmVudE9wdGlvbnMsXG4gICAgd2luZG93OiB3aW5kb3csXG4gICAgZW5hYmxlZDogZW5hYmxlZFxuICB9KTtcbiAgb3B0cy5zY3JvbGwgPSBnZXRJbnRlcm5hbENvb3JkaW5hdGVzT3B0aW9ucyhyZXN0KTtcbiAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBfYnVpbGRXaGVlbENvbmZpZyhfcmVmNikge1xuICB2YXIgZG9tVGFyZ2V0ID0gX3JlZjYuZG9tVGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zID0gX3JlZjYuZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93ID0gX3JlZjYud2luZG93LFxuICAgICAgZW5hYmxlZCA9IF9yZWY2LmVuYWJsZWQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjYsIFtcImRvbVRhcmdldFwiLCBcImV2ZW50T3B0aW9uc1wiLCBcIndpbmRvd1wiLCBcImVuYWJsZWRcIl0pO1xuXG4gIHZhciBvcHRzID0gZ2V0SW50ZXJuYWxHZW5lcmljT3B0aW9ucyh7XG4gICAgZG9tVGFyZ2V0OiBkb21UYXJnZXQsXG4gICAgZXZlbnRPcHRpb25zOiBldmVudE9wdGlvbnMsXG4gICAgd2luZG93OiB3aW5kb3csXG4gICAgZW5hYmxlZDogZW5hYmxlZFxuICB9KTtcbiAgb3B0cy53aGVlbCA9IGdldEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zKHJlc3QpO1xuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29tcGxleENvbmZpZyhjb25maWcsIGFjdGlvbnMpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBpZiAoYWN0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHZhciBfY29uZmlnID0gY29uZmlnLFxuICAgICAgZHJhZyA9IF9jb25maWcuZHJhZyxcbiAgICAgIHdoZWVsID0gX2NvbmZpZy53aGVlbCxcbiAgICAgIG1vdmUgPSBfY29uZmlnLm1vdmUsXG4gICAgICBzY3JvbGwgPSBfY29uZmlnLnNjcm9sbCxcbiAgICAgIHBpbmNoID0gX2NvbmZpZy5waW5jaCxcbiAgICAgIGhvdmVyID0gX2NvbmZpZy5ob3ZlcixcbiAgICAgIGV2ZW50T3B0aW9ucyA9IF9jb25maWcuZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93ID0gX2NvbmZpZy53aW5kb3csXG4gICAgICBkb21UYXJnZXQgPSBfY29uZmlnLmRvbVRhcmdldCxcbiAgICAgIGVuYWJsZWQgPSBfY29uZmlnLmVuYWJsZWQ7XG4gIHZhciBtZXJnZWRDb25maWcgPSBnZXRJbnRlcm5hbEdlbmVyaWNPcHRpb25zKHtcbiAgICBldmVudE9wdGlvbnM6IGV2ZW50T3B0aW9ucyxcbiAgICB3aW5kb3c6IHdpbmRvdyxcbiAgICBkb21UYXJnZXQ6IGRvbVRhcmdldCxcbiAgICBlbmFibGVkOiBlbmFibGVkXG4gIH0pO1xuICBpZiAoYWN0aW9ucy5oYXMoJ29uRHJhZycpKSBtZXJnZWRDb25maWcuZHJhZyA9IGdldEludGVybmFsRHJhZ09wdGlvbnMoZHJhZyk7XG4gIGlmIChhY3Rpb25zLmhhcygnb25XaGVlbCcpKSBtZXJnZWRDb25maWcud2hlZWwgPSBnZXRJbnRlcm5hbENvb3JkaW5hdGVzT3B0aW9ucyh3aGVlbCk7XG4gIGlmIChhY3Rpb25zLmhhcygnb25TY3JvbGwnKSkgbWVyZ2VkQ29uZmlnLnNjcm9sbCA9IGdldEludGVybmFsQ29vcmRpbmF0ZXNPcHRpb25zKHNjcm9sbCk7XG4gIGlmIChhY3Rpb25zLmhhcygnb25Nb3ZlJykpIG1lcmdlZENvbmZpZy5tb3ZlID0gZ2V0SW50ZXJuYWxDb29yZGluYXRlc09wdGlvbnMobW92ZSk7XG4gIGlmIChhY3Rpb25zLmhhcygnb25QaW5jaCcpKSBtZXJnZWRDb25maWcucGluY2ggPSBnZXRJbnRlcm5hbERpc3RhbmNlQW5nbGVPcHRpb25zKHBpbmNoKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbkhvdmVyJykpIG1lcmdlZENvbmZpZy5ob3ZlciA9IF9leHRlbmRzKHtcbiAgICBlbmFibGVkOiB0cnVlXG4gIH0sIGhvdmVyKTtcbiAgcmV0dXJuIG1lcmdlZENvbmZpZztcbn1cblxuZnVuY3Rpb24gZ2V0SW5pdGlhbChtaXhlZCkge1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIF9hY3RpdmU6IGZhbHNlLFxuICAgIF9ibG9ja2VkOiBmYWxzZSxcbiAgICBfaW50ZW50aW9uYWw6IFtmYWxzZSwgZmFsc2VdLFxuICAgIF9tb3ZlbWVudDogWzAsIDBdLFxuICAgIF9pbml0aWFsOiBbMCwgMF0sXG4gICAgX2JvdW5kczogW1stSW5maW5pdHksIEluZmluaXR5XSwgWy1JbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICBfbGFzdEV2ZW50VHlwZTogdW5kZWZpbmVkLFxuICAgIGV2ZW50OiB1bmRlZmluZWQsXG4gICAgLy8gY3VycmVudFRhcmdldDogdW5kZWZpbmVkLFxuICAgIC8vIHBvaW50ZXJJZDogdW5kZWZpbmVkLFxuICAgIGludGVudGlvbmFsOiBmYWxzZSxcbiAgICB2YWx1ZXM6IFswLCAwXSxcbiAgICB2ZWxvY2l0aWVzOiBbMCwgMF0sXG4gICAgZGVsdGE6IFswLCAwXSxcbiAgICBtb3ZlbWVudDogWzAsIDBdLFxuICAgIG9mZnNldDogWzAsIDBdLFxuICAgIGxhc3RPZmZzZXQ6IFswLCAwXSxcbiAgICBkaXJlY3Rpb246IFswLCAwXSxcbiAgICBpbml0aWFsOiBbMCwgMF0sXG4gICAgcHJldmlvdXM6IFswLCAwXSxcbiAgICBmaXJzdDogZmFsc2UsXG4gICAgbGFzdDogZmFsc2UsXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICB0aW1lU3RhbXA6IDAsXG4gICAgc3RhcnRUaW1lOiAwLFxuICAgIGVsYXBzZWRUaW1lOiAwLFxuICAgIGNhbmNlbDogbm9vcCxcbiAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgbWVtbzogdW5kZWZpbmVkLFxuICAgIGFyZ3M6IHVuZGVmaW5lZFxuICB9LCBtaXhlZCk7XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgdmFyIHNoYXJlZCA9IHtcbiAgICBob3ZlcmluZzogZmFsc2UsXG4gICAgc2Nyb2xsaW5nOiBmYWxzZSxcbiAgICB3aGVlbGluZzogZmFsc2UsXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIG1vdmluZzogZmFsc2UsXG4gICAgcGluY2hpbmc6IGZhbHNlLFxuICAgIHRvdWNoZXM6IDAsXG4gICAgYnV0dG9uczogMCxcbiAgICBkb3duOiBmYWxzZSxcbiAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgYWx0S2V5OiBmYWxzZSxcbiAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICBjdHJsS2V5OiBmYWxzZVxuICB9O1xuICB2YXIgZHJhZyA9IGdldEluaXRpYWwoe1xuICAgIGF4aXM6IHVuZGVmaW5lZCxcbiAgICB4eTogWzAsIDBdLFxuICAgIHZ4dnk6IFswLCAwXSxcbiAgICB2ZWxvY2l0eTogMCxcbiAgICBkaXN0YW5jZTogMCxcbiAgICBfaXNUYXA6IHRydWUsXG4gICAgX2RlbGF5ZWRFdmVudDogZmFsc2UsXG4gICAgX3BvaW50ZXJJZDogdW5kZWZpbmVkLFxuICAgIHRhcDogZmFsc2UsXG4gICAgc3dpcGU6IFswLCAwXVxuICB9KTtcbiAgdmFyIHBpbmNoID0gZ2V0SW5pdGlhbCh7XG4gICAgZGE6IFswLCAwXSxcbiAgICB2ZHZhOiBbMCwgMF0sXG4gICAgLy8gQHRzLWlnbm9yZSBvcmlnaW4gY2FuIG5ldmVyIGJlIHBhc3NlZCBhcyB1bmRlZmluZWQgaW4gdXNlcmxhbmRcbiAgICBvcmlnaW46IHVuZGVmaW5lZCxcbiAgICB0dXJuczogMFxuICB9KTtcbiAgdmFyIHdoZWVsID0gZ2V0SW5pdGlhbCh7XG4gICAgYXhpczogdW5kZWZpbmVkLFxuICAgIHh5OiBbMCwgMF0sXG4gICAgdnh2eTogWzAsIDBdLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIGRpc3RhbmNlOiAwXG4gIH0pO1xuICB2YXIgbW92ZSA9IGdldEluaXRpYWwoe1xuICAgIGF4aXM6IHVuZGVmaW5lZCxcbiAgICB4eTogWzAsIDBdLFxuICAgIHZ4dnk6IFswLCAwXSxcbiAgICB2ZWxvY2l0eTogMCxcbiAgICBkaXN0YW5jZTogMFxuICB9KTtcbiAgdmFyIHNjcm9sbCA9IGdldEluaXRpYWwoe1xuICAgIGF4aXM6IHVuZGVmaW5lZCxcbiAgICB4eTogWzAsIDBdLFxuICAgIHZ4dnk6IFswLCAwXSxcbiAgICB2ZWxvY2l0eTogMCxcbiAgICBkaXN0YW5jZTogMFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzaGFyZWQ6IHNoYXJlZCxcbiAgICBkcmFnOiBkcmFnLFxuICAgIHBpbmNoOiBwaW5jaCxcbiAgICB3aGVlbDogd2hlZWwsXG4gICAgbW92ZTogbW92ZSxcbiAgICBzY3JvbGw6IHNjcm9sbFxuICB9O1xufVxuXG52YXIgUmVjb2duaXplcnNNYXAgPSAvKiNfX1BVUkVfXyovbmV3IE1hcCgpO1xuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFJlY29nbml6ZXIgYWJzdHJhY3QgY2xhc3MuXHJcbiAqL1xuXG52YXIgUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBnZXN0dXJlIHJlY29nbml6ZXIuXHJcbiAgICogQHBhcmFtIHN0YXRlS2V5IGRyYWcsIG1vdmUsIHBpbmNoLCBldGMuXHJcbiAgICogQHBhcmFtIGNvbnRyb2xsZXIgdGhlIGNvbnRyb2xsZXIgYXR0YWNoZWQgdG8gdGhlIGdlc3R1cmVcclxuICAgKiBAcGFyYW0gW2FyZ3NdIHRoZSBhcmdzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgZ2VzdHVyZSBoYW5kbGVyXHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlY29nbml6ZXIoY29udHJvbGxlciwgYXJncykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG4gICAgICBhcmdzID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuZGVib3VuY2VkID0gdHJ1ZTsgLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHNldCBhIHRpbWVvdXQgZm9yIGEgZ2l2ZW4gZ2VzdHVyZVxuXG4gICAgdGhpcy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBtcykge1xuICAgICAgdmFyIF93aW5kb3c7XG5cbiAgICAgIGlmIChtcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1zID0gMTQwO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuY29udHJvbGxlci50aW1lb3V0c1tfdGhpcy5zdGF0ZUtleV0pO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jb250cm9sbGVyLnRpbWVvdXRzW190aGlzLnN0YXRlS2V5XSA9IChfd2luZG93ID0gd2luZG93KS5zZXRUaW1lb3V0LmFwcGx5KF93aW5kb3csIFtjYWxsYmFjaywgbXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfTsgLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNsZWFyIGEgdGltZW91dCBmb3IgYSBnaXZlbiBnZXN0dXJlXG5cblxuICAgIHRoaXMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNvbnRyb2xsZXIudGltZW91dHNbX3RoaXMuc3RhdGVLZXldKTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogRmlyZXMgdGhlIGdlc3R1cmUgaGFuZGxlclxyXG4gICAgICovXG5cblxuICAgIHRoaXMuZmlyZUdlc3R1cmVIYW5kbGVyID0gZnVuY3Rpb24gKGZvcmNlRmxhZykge1xuICAgICAgaWYgKGZvcmNlRmxhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZvcmNlRmxhZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcclxuICAgICAgICogSWYgdGhlIGdlc3R1cmUgaGFzIGJlZW4gYmxvY2tlZCAodGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIGdlc3R1cmUgaGFzIHN0YXJ0ZWQgaW4gYW4gdW53YW50ZWQgZGlyZWN0aW9uKSxcclxuICAgICAgICogY2xlYW4gZXZlcnl0aGluZyBhbmQgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAqL1xuICAgICAgaWYgKF90aGlzLnN0YXRlLl9ibG9ja2VkKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgZGVib3VuY2VkIGdlc3R1cmVzIHRvIGVuZCBieSB0aGVtc2VsdmVzXG4gICAgICAgIGlmICghX3RoaXMuZGVib3VuY2VkKSB7XG4gICAgICAgICAgX3RoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgX3RoaXMuY2xlYW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBJZiB0aGUgZ2VzdHVyZSBoYXMgbm8gaW50ZW50aW9uYWwgZGltZW5zaW9uLCBkb24ndCBmaXJlIHRoZSBoYW5kbGVyLlxuXG5cbiAgICAgIGlmICghZm9yY2VGbGFnICYmICFfdGhpcy5zdGF0ZS5pbnRlbnRpb25hbCAmJiAhX3RoaXMuY29uZmlnLnRyaWdnZXJBbGxFdmVudHMpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUuaW50ZW50aW9uYWwpIHtcbiAgICAgICAgdmFyIHByZXZfYWN0aXZlID0gX3RoaXMuc3RhdGUuYWN0aXZlO1xuICAgICAgICB2YXIgbmV4dF9hY3RpdmUgPSBfdGhpcy5zdGF0ZS5fYWN0aXZlO1xuICAgICAgICBfdGhpcy5zdGF0ZS5hY3RpdmUgPSBuZXh0X2FjdGl2ZTtcbiAgICAgICAgX3RoaXMuc3RhdGUuZmlyc3QgPSBuZXh0X2FjdGl2ZSAmJiAhcHJldl9hY3RpdmU7XG4gICAgICAgIF90aGlzLnN0YXRlLmxhc3QgPSBwcmV2X2FjdGl2ZSAmJiAhbmV4dF9hY3RpdmU7XG4gICAgICAgIF90aGlzLmNvbnRyb2xsZXIuc3RhdGUuc2hhcmVkW190aGlzLmluZ0tleV0gPSBuZXh0X2FjdGl2ZTsgLy8gU2V0cyBkcmFnZ2luZywgcGluY2hpbmcsIGV0Yy4gdG8gdGhlIGdlc3R1cmUgYWN0aXZlIHN0YXRlXG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IF9leHRlbmRzKHt9LCBfdGhpcy5jb250cm9sbGVyLnN0YXRlLnNoYXJlZCwgX3RoaXMuc3RhdGUsIF90aGlzLm1hcFN0YXRlVmFsdWVzKF90aGlzLnN0YXRlKSk7IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgICB2YXIgbmV3TWVtbyA9IF90aGlzLmhhbmRsZXIoc3RhdGUpOyAvLyBTZXRzIG1lbW8gdG8gdGhlIHJldHVybmVkIHZhbHVlIG9mIHRoZSBoYW5kbGVyICh1bmxlc3MgaXQncyBub3QgdW5kZWZpbmVkKVxuXG5cbiAgICAgIF90aGlzLnN0YXRlLm1lbW8gPSBuZXdNZW1vICE9PSB2b2lkIDAgPyBuZXdNZW1vIDogX3RoaXMuc3RhdGUubWVtbzsgLy8gQ2xlYW5zIHRoZSBnZXN0dXJlIHdoZW4gdGhlIGdlc3R1cmUgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cblxuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5fYWN0aXZlKSBfdGhpcy5jbGVhbigpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gIH0gLy8gUmV0dXJucyB0aGUgZ2VzdHVyZSBjb25maWdcblxuXG4gIHZhciBfcHJvdG8gPSBSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICAvLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gdXBkYXRlIHRoZSBzaGFyZWQgc3RhdGVcbiAgX3Byb3RvLnVwZGF0ZVNoYXJlZFN0YXRlID0gZnVuY3Rpb24gdXBkYXRlU2hhcmVkU3RhdGUoc2hhcmVkU3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udHJvbGxlci5zdGF0ZS5zaGFyZWQsIHNoYXJlZFN0YXRlKTtcbiAgfSAvLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gdXBkYXRlIHRoZSBnZXN0dXJlIHN0YXRlXG4gIDtcblxuICBfcHJvdG8udXBkYXRlR2VzdHVyZVN0YXRlID0gZnVuY3Rpb24gdXBkYXRlR2VzdHVyZVN0YXRlKGdlc3R1cmVTdGF0ZSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5zdGF0ZSwgZ2VzdHVyZVN0YXRlKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHN0YXRlIHByb3BlcnRpZXMgZGVwZW5kaW5nIG9uIHRoZSBtb3ZlbWVudCBhbmQgc3RhdGUuXHJcbiAgICpcclxuICAgKiBTaG91bGQgYmUgb3ZlcnJpZGVuIGZvciBjdXN0b20gYmVoYXZpb3IsIGRvZXNuJ3QgZG8gYW55dGhpbmcgaW4gdGhlIGltcGxlbWVudGF0aW9uXHJcbiAgICogYmVsb3cuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2hlY2tJbnRlbnRpb25hbGl0eSA9IGZ1bmN0aW9uIGNoZWNrSW50ZW50aW9uYWxpdHkoX2ludGVudGlvbmFsLCBfbW92ZW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2ludGVudGlvbmFsOiBfaW50ZW50aW9uYWwsXG4gICAgICBfYmxvY2tlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgYmFzaWMgbW92ZW1lbnQgcHJvcGVydGllcyBmb3IgdGhlIGdlc3R1cmUgYmFzZWQgb24gdGhlIG5leHQgdmFsdWVzIGFuZCBjdXJyZW50IHN0YXRlLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldE1vdmVtZW50ID0gZnVuY3Rpb24gZ2V0TW92ZW1lbnQodmFsdWVzKSB7XG4gICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBpbml0aWFsID0gX3RoaXMkY29uZmlnLmluaXRpYWwsXG4gICAgICAgIGJvdW5kcyA9IF90aGlzJGNvbmZpZy5ib3VuZHMsXG4gICAgICAgIHJ1YmJlcmJhbmQgPSBfdGhpcyRjb25maWcucnViYmVyYmFuZCxcbiAgICAgICAgVCA9IF90aGlzJGNvbmZpZy50aHJlc2hvbGQ7XG4gICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgX2JvdW5kcyA9IF90aGlzJHN0YXRlLl9ib3VuZHMsXG4gICAgICAgIF9pbml0aWFsID0gX3RoaXMkc3RhdGUuX2luaXRpYWwsXG4gICAgICAgIF9hY3RpdmUgPSBfdGhpcyRzdGF0ZS5fYWN0aXZlLFxuICAgICAgICB3YXNJbnRlbnRpb25hbCA9IF90aGlzJHN0YXRlLl9pbnRlbnRpb25hbCxcbiAgICAgICAgbGFzdE9mZnNldCA9IF90aGlzJHN0YXRlLmxhc3RPZmZzZXQsXG4gICAgICAgIHByZXZNb3ZlbWVudCA9IF90aGlzJHN0YXRlLm1vdmVtZW50O1xuICAgIHZhciBNID0gdGhpcy5nZXRJbnRlcm5hbE1vdmVtZW50KHZhbHVlcywgdGhpcy5zdGF0ZSk7XG4gICAgdmFyIGkwID0gd2FzSW50ZW50aW9uYWxbMF0gPT09IGZhbHNlID8gZ2V0SW50ZW50aW9uYWxEaXNwbGFjZW1lbnQoTVswXSwgVFswXSkgOiB3YXNJbnRlbnRpb25hbFswXTtcbiAgICB2YXIgaTEgPSB3YXNJbnRlbnRpb25hbFsxXSA9PT0gZmFsc2UgPyBnZXRJbnRlbnRpb25hbERpc3BsYWNlbWVudChNWzFdLCBUWzFdKSA6IHdhc0ludGVudGlvbmFsWzFdOyAvLyBHZXQgZ2VzdHVyZSBzcGVjaWZpYyBzdGF0ZSBwcm9wZXJ0aWVzIGJhc2VkIG9uIGludGVudGlvbmFsaXR5IGFuZCBtb3ZlbWVudC5cblxuICAgIHZhciBpbnRlbnRpb25hbGl0eUNoZWNrID0gdGhpcy5jaGVja0ludGVudGlvbmFsaXR5KFtpMCwgaTFdLCBNKTtcblxuICAgIGlmIChpbnRlbnRpb25hbGl0eUNoZWNrLl9ibG9ja2VkKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGludGVudGlvbmFsaXR5Q2hlY2ssIHtcbiAgICAgICAgX21vdmVtZW50OiBNLFxuICAgICAgICBkZWx0YTogWzAsIDBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgX2ludGVudGlvbmFsID0gaW50ZW50aW9uYWxpdHlDaGVjay5faW50ZW50aW9uYWw7XG4gICAgdmFyIF9tb3ZlbWVudCA9IE07XG5cbiAgICB2YXIgX19jYWNoZWRCb3VuZHM7XG5cbiAgICB2YXIgX19jYWNoZWRJbml0aWFsO1xuXG4gICAgaWYgKF9pbnRlbnRpb25hbFswXSAhPT0gZmFsc2UgJiYgd2FzSW50ZW50aW9uYWxbMF0gPT09IGZhbHNlKSB7XG4gICAgICBfX2NhY2hlZEluaXRpYWwgPSB2YWx1ZUZuKGluaXRpYWwsIHRoaXMuc3RhdGUpO1xuICAgICAgX19jYWNoZWRCb3VuZHMgPSB2YWx1ZUZuKGJvdW5kcywgdGhpcy5zdGF0ZSk7XG4gICAgICBfaW5pdGlhbFswXSA9IF9fY2FjaGVkSW5pdGlhbFswXTtcbiAgICAgIF9ib3VuZHNbMF0gPSBfX2NhY2hlZEJvdW5kc1swXTtcbiAgICB9XG5cbiAgICBpZiAoX2ludGVudGlvbmFsWzFdICE9PSBmYWxzZSAmJiB3YXNJbnRlbnRpb25hbFsxXSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBfY2FjaGVkSW5pdGlhbCwgX2NhY2hlZEJvdW5kcztcblxuICAgICAgX19jYWNoZWRJbml0aWFsID0gKF9jYWNoZWRJbml0aWFsID0gX19jYWNoZWRJbml0aWFsKSAhPSBudWxsID8gX2NhY2hlZEluaXRpYWwgOiB2YWx1ZUZuKGluaXRpYWwsIHRoaXMuc3RhdGUpO1xuICAgICAgX19jYWNoZWRCb3VuZHMgPSAoX2NhY2hlZEJvdW5kcyA9IF9fY2FjaGVkQm91bmRzKSAhPSBudWxsID8gX2NhY2hlZEJvdW5kcyA6IHZhbHVlRm4oYm91bmRzLCB0aGlzLnN0YXRlKTtcbiAgICAgIF9pbml0aWFsWzFdID0gX19jYWNoZWRJbml0aWFsWzFdO1xuICAgICAgX2JvdW5kc1sxXSA9IF9fY2FjaGVkQm91bmRzWzFdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFRoZSBtb3ZlbWVudCBzZW50IHRvIHRoZSBoYW5kbGVyIGhhcyAwIGluIGl0cyBkaW1lbnNpb25zIHdoZW4gaW50ZW50aW9uYWxpdHkgaXMgZmFsc2UuXHJcbiAgICAgKiBJdCBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGFjdHVhbCBtb3ZlbWVudCBtaW51cyB0aGUgdGhyZXNob2xkLlxyXG4gICAgICovXG5cblxuICAgIHZhciBtb3ZlbWVudCA9IFtfaW50ZW50aW9uYWxbMF0gIT09IGZhbHNlID8gTVswXSAtIF9pbnRlbnRpb25hbFswXSA6IF9pbml0aWFsWzBdLCBfaW50ZW50aW9uYWxbMV0gIT09IGZhbHNlID8gTVsxXSAtIF9pbnRlbnRpb25hbFsxXSA6IF9pbml0aWFsWzFdXTtcbiAgICB2YXIgb2Zmc2V0ID0gYWRkVihtb3ZlbWVudCwgbGFzdE9mZnNldCk7XG4gICAgLyoqXHJcbiAgICAgKiBSdWJiZXJiYW5kIHNob3VsZCBiZSAwIHdoZW4gdGhlIGdlc3R1cmUgaXMgbm8gbG9uZ2VyIGFjdGl2ZSwgc28gdGhhdCBtb3ZlbWVudFxyXG4gICAgICogYW5kIG9mZnNldCBjYW4gcmV0dXJuIHdpdGhpbiB0aGVpciBib3VuZHMuXHJcbiAgICAgKi9cblxuICAgIHZhciBfcnViYmVyYmFuZCA9IF9hY3RpdmUgPyBydWJiZXJiYW5kIDogWzAsIDBdO1xuXG4gICAgbW92ZW1lbnQgPSBjb21wdXRlUnViYmVyYmFuZChfYm91bmRzLCBhZGRWKG1vdmVtZW50LCBfaW5pdGlhbCksIF9ydWJiZXJiYW5kKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGludGVudGlvbmFsaXR5Q2hlY2ssIHtcbiAgICAgIGludGVudGlvbmFsOiBfaW50ZW50aW9uYWxbMF0gIT09IGZhbHNlIHx8IF9pbnRlbnRpb25hbFsxXSAhPT0gZmFsc2UsXG4gICAgICBfaW5pdGlhbDogX2luaXRpYWwsXG4gICAgICBfbW92ZW1lbnQ6IF9tb3ZlbWVudCxcbiAgICAgIG1vdmVtZW50OiBtb3ZlbWVudCxcbiAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgb2Zmc2V0OiBjb21wdXRlUnViYmVyYmFuZChfYm91bmRzLCBvZmZzZXQsIF9ydWJiZXJiYW5kKSxcbiAgICAgIGRlbHRhOiBzdWJWKG1vdmVtZW50LCBwcmV2TW92ZW1lbnQpXG4gICAgfSk7XG4gIH0gLy8gQ2xlYW5zIHRoZSBnZXN0dXJlLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGdlc3R1cmVzLlxuICA7XG5cbiAgX3Byb3RvLmNsZWFuID0gZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUmVjb2duaXplciwgW3tcbiAgICBrZXk6IFwiY29uZmlnXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyLmNvbmZpZ1t0aGlzLnN0YXRlS2V5XTtcbiAgICB9IC8vIElzIHRoZSBnZXN0dXJlIGVuYWJsZWRcblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIuY29uZmlnLmVuYWJsZWQgJiYgdGhpcy5jb25maWcuZW5hYmxlZDtcbiAgICB9IC8vIFJldHVybnMgdGhlIGNvbnRyb2xsZXIgc3RhdGUgZm9yIGEgZ2l2ZW4gZ2VzdHVyZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIuc3RhdGVbdGhpcy5zdGF0ZUtleV07XG4gICAgfSAvLyBSZXR1cm5zIHRoZSBnZXN0dXJlIGhhbmRsZXJcblxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnNbdGhpcy5zdGF0ZUtleV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlY29nbml6ZXI7XG59KCk7IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0SW50ZW50aW9uYWxEaXNwbGFjZW1lbnQobW92ZW1lbnQsIHRocmVzaG9sZCkge1xuICBpZiAoTWF0aC5hYnMobW92ZW1lbnQpID49IHRocmVzaG9sZCkge1xuICAgIHJldHVybiBzaWduKG1vdmVtZW50KSAqIHRocmVzaG9sZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVJ1YmJlcmJhbmQoYm91bmRzLCBfcmVmLCBfcmVmMikge1xuICB2YXIgVnggPSBfcmVmWzBdLFxuICAgICAgVnkgPSBfcmVmWzFdO1xuICB2YXIgUnggPSBfcmVmMlswXSxcbiAgICAgIFJ5ID0gX3JlZjJbMV07XG4gIHZhciBfYm91bmRzJCA9IGJvdW5kc1swXSxcbiAgICAgIFgxID0gX2JvdW5kcyRbMF0sXG4gICAgICBYMiA9IF9ib3VuZHMkWzFdLFxuICAgICAgX2JvdW5kcyQyID0gYm91bmRzWzFdLFxuICAgICAgWTEgPSBfYm91bmRzJDJbMF0sXG4gICAgICBZMiA9IF9ib3VuZHMkMlsxXTtcbiAgcmV0dXJuIFtydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhWeCwgWDEsIFgyLCBSeCksIHJ1YmJlcmJhbmRJZk91dE9mQm91bmRzKFZ5LCBZMSwgWTIsIFJ5KV07XG59XG4vKipcclxuICogUmV0dXJucyBhIGdlbmVyaWMsIGNvbW1vbiBwYXlsb2FkIGZvciBhbGwgZ2VzdHVyZXMgZnJvbSBhbiBldmVudC5cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0R2VuZXJpY1BheWxvYWQoX3JlZjMsIGV2ZW50LCBpc1N0YXJ0RXZlbnQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjMuc3RhdGUsXG4gICAgICBhcmdzID0gX3JlZjMuYXJncztcbiAgdmFyIHRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcCxcbiAgICAgIF9sYXN0RXZlbnRUeXBlID0gZXZlbnQudHlwZTtcbiAgdmFyIHByZXZpb3VzID0gc3RhdGUudmFsdWVzO1xuICB2YXIgZWxhcHNlZFRpbWUgPSBpc1N0YXJ0RXZlbnQgPyAwIDogdGltZVN0YW1wIC0gc3RhdGUuc3RhcnRUaW1lO1xuICByZXR1cm4ge1xuICAgIF9sYXN0RXZlbnRUeXBlOiBfbGFzdEV2ZW50VHlwZSxcbiAgICBldmVudDogZXZlbnQsXG4gICAgdGltZVN0YW1wOiB0aW1lU3RhbXAsXG4gICAgZWxhcHNlZFRpbWU6IGVsYXBzZWRUaW1lLFxuICAgIGFyZ3M6IGFyZ3MsXG4gICAgcHJldmlvdXM6IHByZXZpb3VzXG4gIH07XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgcmVpbml0aWFsaXplZCBzdGFydCBzdGF0ZSBmb3IgdGhlIGdlc3R1cmUuXHJcbiAqIFNob3VsZCBiZSBjb21tb24gdG8gYWxsIGdlc3R1cmVzLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0U3RhcnRHZXN0dXJlU3RhdGUocmVjb2duaXplciwgdmFsdWVzLCBldmVudCkge1xuICB2YXIgb2Zmc2V0ID0gcmVjb2duaXplci5zdGF0ZS5vZmZzZXQ7XG4gIHZhciBzdGFydFRpbWUgPSBldmVudC50aW1lU3RhbXA7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZ2V0SW5pdGlhbFN0YXRlKClbcmVjb2duaXplci5zdGF0ZUtleV0sIHtcbiAgICBfYWN0aXZlOiB0cnVlLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIGluaXRpYWw6IHZhbHVlcyxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBsYXN0T2Zmc2V0OiBvZmZzZXQsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWwoZnVuYywgc3RhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZnVuYy5jYWxsLmFwcGx5KGZ1bmMsIFt0aGlzLCBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pXS5jb25jYXQoYXJncykpO1xuICB9O1xufVxuLyoqXHJcbiAqIFRoZSBjb250cm9sbGVyIHdpbGwga2VlcCB0cmFjayBvZiB0aGUgc3RhdGUgZm9yIGFsbCBnZXN0dXJlcyBhbmQgYWxzbyBrZWVwXHJcbiAqIHRyYWNrIG9mIHRpbWVvdXRzLCBhbmQgd2luZG93IGxpc3RlbmVycy5cclxuICovXG5cblxudmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbiBDb250cm9sbGVyKGNsYXNzZXMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuXG4gIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmluZGluZ3MgPSB7fTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXMuY2xhc3NlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgUmVjb2duaXplckNsYXNzID0gX3N0ZXAudmFsdWU7XG4gICAgICBuZXcgUmVjb2duaXplckNsYXNzKF90aGlzLCBhcmdzKS5hZGRCaW5kaW5ncyhiaW5kaW5ncyk7XG4gICAgfSAvLyB3ZSBhbHNvIGFkZCBldmVudCBiaW5kaW5ncyBmb3IgbmF0aXZlIGhhbmRsZXJzXG5cblxuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoX3RoaXMubmF0aXZlUmVmcyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IF9PYmplY3QkZW50cmllc1tfaV0sXG4gICAgICAgICAgZXZlbnQgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgaGFuZGxlciA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCBldmVudCwgcGFydGlhbChoYW5kbGVyLCBfZXh0ZW5kcyh7fSwgX3RoaXMuc3RhdGUuc2hhcmVkLCB7XG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgIH0pKSk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmNvbmZpZy5kb21UYXJnZXQpIHtcbiAgICAgIC8vIElmIGNvbmZpZy5kb21UYXJnZXQgaXMgc2V0IHdlIGFkZCBldmVudCBsaXN0ZW5lcnMgdG8gaXQgYW5kIHJldHVybiB0aGUgY2xlYW4gZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdXBkYXRlRG9tTGlzdGVuZXJzKF90aGlzLCBiaW5kaW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCwgd2UgcmV0dXJuIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGdlc3R1cmUgaGFuZGxlcnMgbWFwcGVkIHRvIHJlYWN0IGhhbmRsZXIgZXZlbnQga2V5cy5cbiAgICAgIHJldHVybiBnZXRQcm9wc0xpc3RlbmVyKF90aGlzLCBiaW5kaW5ncyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfdGhpcy5jb25maWcuZG9tVGFyZ2V0KSBfdGhpcy5iaW5kKCk7XG4gICAgcmV0dXJuIF90aGlzLmNsZWFuO1xuICB9O1xuICAvKipcclxuICAgKiBGdW5jdGlvbiByYW4gb24gY29tcG9uZW50IHVubW91bnQ6IGNsZWFucyB0aW1lb3V0cyBhbmQgcmVtb3ZlcyBkb20gbGlzdGVuZXJzIHNldCBieSB0aGUgYmluZCBmdW5jdGlvbi5cclxuICAgKi9cblxuXG4gIHRoaXMuY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvbVRhcmdldCA9IGdldERvbVRhcmdldEZyb21Db25maWcoX3RoaXMuY29uZmlnKTtcbiAgICB2YXIgZXZlbnRPcHRpb25zID0gX3RoaXMuY29uZmlnLmV2ZW50T3B0aW9ucztcbiAgICBpZiAoZG9tVGFyZ2V0KSByZW1vdmVMaXN0ZW5lcnMoZG9tVGFyZ2V0LCB0YWtlQWxsKF90aGlzLmRvbUxpc3RlbmVycyksIGV2ZW50T3B0aW9ucyk7XG4gICAgT2JqZWN0LnZhbHVlcyhfdGhpcy50aW1lb3V0cykuZm9yRWFjaChjbGVhclRpbWVvdXQpO1xuICAgIGNsZWFyQWxsV2luZG93TGlzdGVuZXJzKF90aGlzKTtcbiAgfTtcblxuICB0aGlzLnN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG4gIHRoaXMudGltZW91dHMgPSB7fTtcbiAgdGhpcy5kb21MaXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB7fTtcbn07XG5mdW5jdGlvbiBjbGVhckFsbFdpbmRvd0xpc3RlbmVycyhjb250cm9sbGVyKSB7XG4gIHZhciBfY29udHJvbGxlciRjb25maWcgPSBjb250cm9sbGVyLmNvbmZpZyxcbiAgICAgIGVsID0gX2NvbnRyb2xsZXIkY29uZmlnLndpbmRvdyxcbiAgICAgIGV2ZW50T3B0aW9ucyA9IF9jb250cm9sbGVyJGNvbmZpZy5ldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3dMaXN0ZW5lcnMgPSBjb250cm9sbGVyLndpbmRvd0xpc3RlbmVycztcbiAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gIGZvciAodmFyIHN0YXRlS2V5IGluIHdpbmRvd0xpc3RlbmVycykge1xuICAgIHZhciBoYW5kbGVycyA9IHdpbmRvd0xpc3RlbmVyc1tzdGF0ZUtleV07XG4gICAgcmVtb3ZlTGlzdGVuZXJzKGVsLCBoYW5kbGVycywgZXZlbnRPcHRpb25zKTtcbiAgfVxuXG4gIGNvbnRyb2xsZXIud2luZG93TGlzdGVuZXJzID0ge307XG59XG5mdW5jdGlvbiBjbGVhcldpbmRvd0xpc3RlbmVycyhfcmVmLCBzdGF0ZUtleSkge1xuICB2YXIgY29uZmlnID0gX3JlZi5jb25maWcsXG4gICAgICB3aW5kb3dMaXN0ZW5lcnMgPSBfcmVmLndpbmRvd0xpc3RlbmVycztcbiAgaWYgKCFjb25maWcud2luZG93KSByZXR1cm47XG4gIHJlbW92ZUxpc3RlbmVycyhjb25maWcud2luZG93LCB3aW5kb3dMaXN0ZW5lcnNbc3RhdGVLZXldLCBjb25maWcuZXZlbnRPcHRpb25zKTtcbiAgZGVsZXRlIHdpbmRvd0xpc3RlbmVyc1tzdGF0ZUtleV07XG59XG5mdW5jdGlvbiB1cGRhdGVXaW5kb3dMaXN0ZW5lcnMoX3JlZjIsIHN0YXRlS2V5LCBsaXN0ZW5lcnMpIHtcbiAgdmFyIGNvbmZpZyA9IF9yZWYyLmNvbmZpZyxcbiAgICAgIHdpbmRvd0xpc3RlbmVycyA9IF9yZWYyLndpbmRvd0xpc3RlbmVycztcblxuICBpZiAobGlzdGVuZXJzID09PSB2b2lkIDApIHtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGlmICghY29uZmlnLndpbmRvdykgcmV0dXJuO1xuICByZW1vdmVMaXN0ZW5lcnMoY29uZmlnLndpbmRvdywgd2luZG93TGlzdGVuZXJzW3N0YXRlS2V5XSwgY29uZmlnLmV2ZW50T3B0aW9ucyk7XG4gIGFkZExpc3RlbmVycyhjb25maWcud2luZG93LCB3aW5kb3dMaXN0ZW5lcnNbc3RhdGVLZXldID0gbGlzdGVuZXJzLCBjb25maWcuZXZlbnRPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRG9tTGlzdGVuZXJzKF9yZWYzLCBiaW5kaW5ncykge1xuICB2YXIgY29uZmlnID0gX3JlZjMuY29uZmlnLFxuICAgICAgZG9tTGlzdGVuZXJzID0gX3JlZjMuZG9tTGlzdGVuZXJzO1xuICB2YXIgZG9tVGFyZ2V0ID0gZ2V0RG9tVGFyZ2V0RnJvbUNvbmZpZyhjb25maWcpO1xuICBpZiAoIWRvbVRhcmdldCkgdGhyb3cgbmV3IEVycm9yKCdkb21UYXJnZXQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIHZhciBldmVudE9wdGlvbnMgPSBjb25maWcuZXZlbnRPcHRpb25zO1xuICByZW1vdmVMaXN0ZW5lcnMoZG9tVGFyZ2V0LCB0YWtlQWxsKGRvbUxpc3RlbmVycyksIGV2ZW50T3B0aW9ucyk7XG5cbiAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRlbnRyaWVzMiA9IE9iamVjdC5lbnRyaWVzKGJpbmRpbmdzKTsgX2kyIDwgX09iamVjdCRlbnRyaWVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9PYmplY3QkZW50cmllczIkX2kgPSBfT2JqZWN0JGVudHJpZXMyW19pMl0sXG4gICAgICAgIGtleSA9IF9PYmplY3QkZW50cmllczIkX2lbMF0sXG4gICAgICAgIGZucyA9IF9PYmplY3QkZW50cmllczIkX2lbMV07XG4gICAgdmFyIG5hbWUgPSBrZXkuc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICBkb21MaXN0ZW5lcnMucHVzaChbbmFtZSwgY2hhaW5GbnMuYXBwbHkodm9pZCAwLCBmbnMpXSk7XG4gIH1cblxuICBhZGRMaXN0ZW5lcnMoZG9tVGFyZ2V0LCBkb21MaXN0ZW5lcnMsIGV2ZW50T3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BzTGlzdGVuZXIoX3JlZjQsIGJpbmRpbmdzKSB7XG4gIHZhciBjb25maWcgPSBfcmVmNC5jb25maWc7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgY2FwdHVyZVN0cmluZyA9IGNvbmZpZy5ldmVudE9wdGlvbnMuY2FwdHVyZSA/ICdDYXB0dXJlJyA6ICcnO1xuXG4gIGZvciAodmFyIF9pMyA9IDAsIF9PYmplY3QkZW50cmllczMgPSBPYmplY3QuZW50cmllcyhiaW5kaW5ncyk7IF9pMyA8IF9PYmplY3QkZW50cmllczMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBfT2JqZWN0JGVudHJpZXMzJF9pID0gX09iamVjdCRlbnRyaWVzM1tfaTNdLFxuICAgICAgICBldmVudCA9IF9PYmplY3QkZW50cmllczMkX2lbMF0sXG4gICAgICAgIGZucyA9IF9PYmplY3QkZW50cmllczMkX2lbMV07XG4gICAgdmFyIGZuc0FycmF5ID0gQXJyYXkuaXNBcnJheShmbnMpID8gZm5zIDogW2Zuc107XG4gICAgdmFyIGtleSA9IGV2ZW50ICsgY2FwdHVyZVN0cmluZztcbiAgICBwcm9wc1trZXldID0gY2hhaW5GbnMuYXBwbHkodm9pZCAwLCBmbnNBcnJheSk7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIHRha2VBbGwoYXJyYXkpIHtcbiAgaWYgKGFycmF5ID09PSB2b2lkIDApIHtcbiAgICBhcnJheSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5LnNwbGljZSgwLCBhcnJheS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBnZXREb21UYXJnZXRGcm9tQ29uZmlnKF9yZWY1KSB7XG4gIHZhciBkb21UYXJnZXQgPSBfcmVmNS5kb21UYXJnZXQ7XG4gIHJldHVybiBkb21UYXJnZXQgJiYgJ2N1cnJlbnQnIGluIGRvbVRhcmdldCA/IGRvbVRhcmdldC5jdXJyZW50IDogZG9tVGFyZ2V0O1xufVxuLyoqXHJcbiAqIGJpbmRpbmdzIGlzIGFuIG9iamVjdCB3aGljaCBrZXlzIG1hdGNoIFJlYWN0RXZlbnRIYW5kbGVyS2V5cy5cclxuICogU2luY2UgYSByZWNvZ25pemVyIG1pZ2h0IHdhbnQgdG8gYmluZCBhIGhhbmRsZXIgZnVuY3Rpb24gdG8gYW4gZXZlbnQga2V5IGFscmVhZHkgdXNlZCBieSBhIHByZXZpb3VzbHlcclxuICogYWRkZWQgcmVjb2duaXplciwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBlYWNoIGV2ZW50IGtleSBpcyBhbiBhcnJheSBvZiBhbGwgdGhlIGZ1bmN0aW9ucyBtYXBwZWQgZm9yXHJcbiAqIHRoYXQga2V5LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRCaW5kaW5ncyhiaW5kaW5ncywgbmFtZSwgZm4pIHtcbiAgaWYgKCFiaW5kaW5nc1tuYW1lXSkgYmluZGluZ3NbbmFtZV0gPSBbXTtcbiAgYmluZGluZ3NbbmFtZV0ucHVzaChmbik7XG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhlbCwgbGlzdGVuZXJzLCBvcHRpb25zKSB7XG4gIGlmIChsaXN0ZW5lcnMgPT09IHZvaWQgMCkge1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGxpc3RlbmVycyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zdGVwMi52YWx1ZSxcbiAgICAgICAgZXZlbnROYW1lID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICBldmVudEhhbmRsZXIgPSBfc3RlcDIkdmFsdWVbMV07XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGVsLCBsaXN0ZW5lcnMsIG9wdGlvbnMpIHtcbiAgaWYgKGxpc3RlbmVycyA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobGlzdGVuZXJzKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICB2YXIgX3N0ZXAzJHZhbHVlID0gX3N0ZXAzLnZhbHVlLFxuICAgICAgICBldmVudE5hbWUgPSBfc3RlcDMkdmFsdWVbMF0sXG4gICAgICAgIGV2ZW50SGFuZGxlciA9IF9zdGVwMyR2YWx1ZVsxXTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbi8qKlxyXG4gKiBVdGlsaXR5IGhvb2sgY2FsbGVkIGJ5IGFsbCBnZXN0dXJlIGhvb2tzIGFuZCB0aGF0IHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIHRoZSBpbnRlcm5hbHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyc1xyXG4gKiBAcGFyYW0gY2xhc3Nlc1xyXG4gKiBAcGFyYW0gY29uZmlnXHJcbiAqIEBwYXJhbSBuYXRpdmVIYW5kbGVycyAtIG5hdGl2ZSBoYW5kbGVycyBzdWNoIGFzIG9uQ2xpY2ssIG9uTW91c2VEb3duLCBldGMuXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VSZWNvZ25pemVycyhoYW5kbGVycywgY29uZmlnLCBuYXRpdmVIYW5kbGVycykge1xuICBpZiAobmF0aXZlSGFuZGxlcnMgPT09IHZvaWQgMCkge1xuICAgIG5hdGl2ZUhhbmRsZXJzID0ge307XG4gIH1cblxuICB2YXIgY2xhc3NlcyA9IHJlc29sdmVDbGFzc2VzKGhhbmRsZXJzKTtcbiAgdmFyIGNvbnRyb2xsZXIgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRyb2xsZXIoY2xhc3Nlcyk7XG4gIH0sIFtdKTtcbiAgY29udHJvbGxlci5jb25maWcgPSBjb25maWc7XG4gIGNvbnRyb2xsZXIuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgY29udHJvbGxlci5uYXRpdmVSZWZzID0gbmF0aXZlSGFuZGxlcnM7XG4gIFJlYWN0LnVzZUVmZmVjdChjb250cm9sbGVyLmVmZmVjdCwgW10pOyAvLyBAdHMtaWdub3JlXG5cbiAgaWYgKGNvbnRyb2xsZXIuY29uZmlnLmRvbVRhcmdldCkgcmV0dXJuIGRlcHJlY2F0aW9uTm90aWNlRm9yRG9tVGFyZ2V0OyAvLyBAdHMtaWdub3JlXG5cbiAgcmV0dXJuIGNvbnRyb2xsZXIuYmluZDtcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRpb25Ob3RpY2VGb3JEb21UYXJnZXQoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnNvbGUud2FybihcIkRlcHJlY2F0aW9uIG5vdGljZTogV2hlbiB0aGUgYGRvbVRhcmdldGAgb3B0aW9uIGlzIHNwZWNpZmllZCwgeW91IGRvbid0IG5lZWQgdG8gd3JpdGUgYHVzZUVmZmVjdChiaW5kLCBbYmluZF0pYCBhbnltb3JlOiBldmVudCBiaW5kaW5nIGlzIG5vdyBtYWRlIGhhbmRsZWQgaW50ZXJuYWxseSB0byB0aGlzIGxpYi5cXG5cXG5OZXh0IHZlcnNpb24gd29uJ3QgcmV0dXJuIGFueXRoaW5nIHdoZW4gYGRvbVRhcmdldGAgaXMgcHJvdmlkZWQsIHRoZXJlZm9yZSB5b3VyIGNvZGUgd2lsbCBicmVhayBpZiB5b3UgdHJ5IHRvIGNhbGwgYHVzZUVmZmVjdGAuXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc2VzKGludGVybmFsSGFuZGxlcnMpIHtcbiAgdmFyIGNsYXNzZXMgPSBuZXcgU2V0KCk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLmRyYWcpIGNsYXNzZXMuYWRkKFJlY29nbml6ZXJzTWFwLmdldCgnZHJhZycpKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMud2hlZWwpIGNsYXNzZXMuYWRkKFJlY29nbml6ZXJzTWFwLmdldCgnd2hlZWwnKSk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLnNjcm9sbCkgY2xhc3Nlcy5hZGQoUmVjb2duaXplcnNNYXAuZ2V0KCdzY3JvbGwnKSk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLm1vdmUpIGNsYXNzZXMuYWRkKFJlY29nbml6ZXJzTWFwLmdldCgnbW92ZScpKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMucGluY2gpIGNsYXNzZXMuYWRkKFJlY29nbml6ZXJzTWFwLmdldCgncGluY2gnKSk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLmhvdmVyKSBjbGFzc2VzLmFkZChSZWNvZ25pemVyc01hcC5nZXQoJ2hvdmVyJykpO1xuICByZXR1cm4gY2xhc3Nlcztcbn1cblxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBjb29yZGluYXRlcy1iYXNlZCBnZXN0dXJlIHJlY29uZ2l6ZXJzXHJcbiAqL1xuXG52YXIgQ29vcmRpbmF0ZXNSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShDb29yZGluYXRlc1JlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBDb29yZGluYXRlc1JlY29nbml6ZXIoKSB7XG4gICAgcmV0dXJuIF9SZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb29yZGluYXRlc1JlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHJlYWwgbW92ZW1lbnQgKHdpdGhvdXQgdGFraW5nIGludGVudGlvbmFsaXR5IGludG8gYWNvdW50KVxyXG4gICAqL1xuICBfcHJvdG8uZ2V0SW50ZXJuYWxNb3ZlbWVudCA9IGZ1bmN0aW9uIGdldEludGVybmFsTW92ZW1lbnQodmFsdWVzLCBzdGF0ZSkge1xuICAgIHJldHVybiBzdWJWKHZhbHVlcywgc3RhdGUuaW5pdGlhbCk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW4gY29vcmRpbmF0ZXMtYmFzZWQgZ2VzdHVyZSwgdGhpcyBmdW5jdGlvbiB3aWxsIGRldGVjdCB0aGUgZmlyc3QgaW50ZW50aW9uYWwgYXhpcyxcclxuICAgKiBsb2NrIHRoZSBnZXN0dXJlIGF4aXMgaWYgbG9ja0RpcmVjdGlvbiBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZywgYmxvY2sgdGhlIGdlc3R1cmVcclxuICAgKiBpZiB0aGUgZmlyc3QgaW50ZW50aW9uYWwgYXhpcyBkb2Vzbid0IG1hdGNoIHRoZSBzcGVjaWZpZWQgYXhpcyBpbiBjb25maWcuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2hlY2tJbnRlbnRpb25hbGl0eSA9IGZ1bmN0aW9uIGNoZWNrSW50ZW50aW9uYWxpdHkoX2ludGVudGlvbmFsLCBfbW92ZW1lbnQpIHtcbiAgICBpZiAoX2ludGVudGlvbmFsWzBdID09PSBmYWxzZSAmJiBfaW50ZW50aW9uYWxbMV0gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfaW50ZW50aW9uYWw6IF9pbnRlbnRpb25hbCxcbiAgICAgICAgYXhpczogdGhpcy5zdGF0ZS5heGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfbW92ZW1lbnQkbWFwID0gX21vdmVtZW50Lm1hcChNYXRoLmFicyksXG4gICAgICAgIGFic1ggPSBfbW92ZW1lbnQkbWFwWzBdLFxuICAgICAgICBhYnNZID0gX21vdmVtZW50JG1hcFsxXTtcblxuICAgIHZhciBheGlzID0gdGhpcy5zdGF0ZS5heGlzIHx8IChhYnNYID4gYWJzWSA/ICd4JyA6IGFic1ggPCBhYnNZID8gJ3knIDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmF4aXMgJiYgIXRoaXMuY29uZmlnLmxvY2tEaXJlY3Rpb24pIHJldHVybiB7XG4gICAgICBfaW50ZW50aW9uYWw6IF9pbnRlbnRpb25hbCxcbiAgICAgIF9ibG9ja2VkOiBmYWxzZSxcbiAgICAgIGF4aXM6IGF4aXNcbiAgICB9O1xuICAgIGlmICghYXhpcykgcmV0dXJuIHtcbiAgICAgIF9pbnRlbnRpb25hbDogW2ZhbHNlLCBmYWxzZV0sXG4gICAgICBfYmxvY2tlZDogZmFsc2UsXG4gICAgICBheGlzOiBheGlzXG4gICAgfTtcbiAgICBpZiAoISF0aGlzLmNvbmZpZy5heGlzICYmIGF4aXMgIT09IHRoaXMuY29uZmlnLmF4aXMpIHJldHVybiB7XG4gICAgICBfaW50ZW50aW9uYWw6IF9pbnRlbnRpb25hbCxcbiAgICAgIF9ibG9ja2VkOiB0cnVlLFxuICAgICAgYXhpczogYXhpc1xuICAgIH07XG4gICAgX2ludGVudGlvbmFsW2F4aXMgPT09ICd4JyA/IDEgOiAwXSA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBfaW50ZW50aW9uYWw6IF9pbnRlbnRpb25hbCxcbiAgICAgIF9ibG9ja2VkOiBmYWxzZSxcbiAgICAgIGF4aXM6IGF4aXNcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRLaW5lbWF0aWNzID0gZnVuY3Rpb24gZ2V0S2luZW1hdGljcyh2YWx1ZXMsIGV2ZW50KSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5nZXRNb3ZlbWVudCh2YWx1ZXMpO1xuXG4gICAgaWYgKCFzdGF0ZS5fYmxvY2tlZCkge1xuICAgICAgdmFyIGR0ID0gZXZlbnQudGltZVN0YW1wIC0gdGhpcy5zdGF0ZS50aW1lU3RhbXA7XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCBjYWxjdWxhdGVBbGxLaW5lbWF0aWNzKHN0YXRlLm1vdmVtZW50LCBzdGF0ZS5kZWx0YSwgZHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG5cbiAgX3Byb3RvLm1hcFN0YXRlVmFsdWVzID0gZnVuY3Rpb24gbWFwU3RhdGVWYWx1ZXMoc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeHk6IHN0YXRlLnZhbHVlcyxcbiAgICAgIHZ4dnk6IHN0YXRlLnZlbG9jaXRpZXNcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBDb29yZGluYXRlc1JlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG52YXIgV0VCS0lUX0RJU1RBTkNFX1NDQUxFX0ZBQ1RPUiA9IDI2MDtcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIEdlc3R1cmVFdmVudCAoaWUgU2FmYXJpKVxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGdlc3R1cmUgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzR2VzdHVyZUV2ZW50cygpIHtcbiAgdHJ5IHtcbiAgICAvLyBUT0RPIFtUU10gcG9zc2libHkgZmluZCBHZXN0dXJlRXZlbnQgZGVmaW5pdGlvbnM/XG4gICAgLy8gQHRzLWlnbm9yZTogbm8gdHlwZSBkZWZpbml0aW9ucyBmb3Igd2Via2l0IEdlc3R1cmVFdmVudHNcbiAgICByZXR1cm4gJ2NvbnN0cnVjdG9yJyBpbiBHZXN0dXJlRXZlbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1cHBvcnRzVG91Y2hFdmVudHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cub250b3VjaHN0YXJ0ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3VjaEV2ZW50cyhldmVudCkge1xuICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldFRvdWNoZXMgPSBldmVudC50YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgIHJldHVybiB0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDAgPyB0YXJnZXRUb3VjaGVzIDogY2hhbmdlZFRvdWNoZXM7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCkge1xuICB2YXIgYnV0dG9ucyA9ICdidXR0b25zJyBpbiBldmVudCA/IGV2ZW50LmJ1dHRvbnMgOiAwO1xuICB2YXIgdG91Y2hFdmVudHMgPSBnZXRUb3VjaEV2ZW50cyhldmVudCk7XG4gIHZhciB0b3VjaGVzID0gdG91Y2hFdmVudHMgJiYgdG91Y2hFdmVudHMubGVuZ3RoIHx8IDA7XG4gIHZhciBkb3duID0gdG91Y2hlcyA+IDAgfHwgYnV0dG9ucyA+IDA7XG4gIHZhciBzaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgYWx0S2V5ID0gZXZlbnQuYWx0S2V5LFxuICAgICAgbWV0YUtleSA9IGV2ZW50Lm1ldGFLZXksXG4gICAgICBjdHJsS2V5ID0gZXZlbnQuY3RybEtleTsgLy8gVE9ETyBjaGVjayBpZiB0aGlzIG1pZ2h0IGNyZWF0ZSBzb21lIG92ZXJyaWRlcz9cblxuICByZXR1cm4ge1xuICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgZG93bjogZG93bixcbiAgICBidXR0b25zOiBidXR0b25zLFxuICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICBhbHRLZXk6IGFsdEtleSxcbiAgICBtZXRhS2V5OiBtZXRhS2V5LFxuICAgIGN0cmxLZXk6IGN0cmxLZXlcbiAgfTtcbn1cbi8qKlxyXG4gKiBHZXRzIHBvaW50ZXIgZXZlbnQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gZXZlbnRcclxuICogQHJldHVybnMgcG9pbnRlciBldmVudCB2YWx1ZXNcclxuICovXG5cbmZ1bmN0aW9uIGdldFBvaW50ZXJFdmVudFZhbHVlcyhldmVudCkge1xuICB2YXIgdG91Y2hFdmVudHMgPSBnZXRUb3VjaEV2ZW50cyhldmVudCk7XG5cbiAgdmFyIF9yZWYgPSB0b3VjaEV2ZW50cyA/IHRvdWNoRXZlbnRzWzBdIDogZXZlbnQsXG4gICAgICBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcblxuICByZXR1cm4gW2NsaWVudFgsIGNsaWVudFldO1xufVxuLyoqXHJcbiAqIEdldHMgc2Nyb2xsIGV2ZW50IHZhbHVlc1xyXG4gKiBAcGFyYW0gZXZlbnRcclxuICogQHJldHVybnMgc2Nyb2xsIGV2ZW50IHZhbHVlc1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsRXZlbnRWYWx1ZXMoZXZlbnQpIHtcbiAgLy8gSWYgdGhlIGN1cnJlbnRUYXJnZXQgaXMgdGhlIHdpbmRvdyB0aGVuIHdlIHJldHVybiB0aGUgc2Nyb2xsWC9ZIHBvc2l0aW9uLlxuICAvLyBJZiBub3QgKGllIHRoZSBjdXJyZW50VGFyZ2V0IGlzIGEgRE9NIGVsZW1lbnQpLCB0aGVuIHdlIHJldHVybiBzY3JvbGxMZWZ0L1RvcFxuICB2YXIgX2V2ZW50JGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgc2Nyb2xsWCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LnNjcm9sbFgsXG4gICAgICBzY3JvbGxZID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsWSxcbiAgICAgIHNjcm9sbExlZnQgPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsVG9wO1xuICByZXR1cm4gW3Njcm9sbFggfHwgc2Nyb2xsTGVmdCB8fCAwLCBzY3JvbGxZIHx8IHNjcm9sbFRvcCB8fCAwXTtcbn1cbi8qKlxyXG4gKiBHZXRzIHdoZWVsIGV2ZW50IHZhbHVlcy5cclxuICogQHBhcmFtIGV2ZW50XHJcbiAqIEByZXR1cm5zIHdoZWVsIGV2ZW50IHZhbHVlc1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0V2hlZWxFdmVudFZhbHVlcyhldmVudCkge1xuICB2YXIgZGVsdGFYID0gZXZlbnQuZGVsdGFYLFxuICAgICAgZGVsdGFZID0gZXZlbnQuZGVsdGFZOyAvL1RPRE8gaW1wbGVtZW50IHBvbHlmaWxsID9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsI1BvbHlmaWxsXG5cbiAgcmV0dXJuIFtkZWx0YVgsIGRlbHRhWV07XG59XG4vKipcclxuICogR2V0cyB3ZWJraXQgZ2VzdHVyZSBldmVudCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKiBAcmV0dXJucyB3ZWJraXQgZ2VzdHVyZSBldmVudCB2YWx1ZXNcclxuICovXG5cbmZ1bmN0aW9uIGdldFdlYmtpdEdlc3R1cmVFdmVudFZhbHVlcyhldmVudCkge1xuICByZXR1cm4gW2V2ZW50LnNjYWxlICogV0VCS0lUX0RJU1RBTkNFX1NDQUxFX0ZBQ1RPUiwgZXZlbnQucm90YXRpb25dO1xufVxuLyoqXHJcbiAqIEdldHMgdHdvIHRvdWNoZXMgZXZlbnQgZGF0YVxyXG4gKiBAcGFyYW0gZXZlbnRcclxuICogQHJldHVybnMgdHdvIHRvdWNoZXMgZXZlbnQgZGF0YVxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHdvVG91Y2hlc0V2ZW50RGF0YShldmVudCkge1xuICB2YXIgX2Ukcm90YXRpb247XG5cbiAgdmFyIHRhcmdldFRvdWNoZXMgPSBldmVudC50YXJnZXRUb3VjaGVzO1xuICB2YXIgQSA9IHRhcmdldFRvdWNoZXNbMF0sXG4gICAgICBCID0gdGFyZ2V0VG91Y2hlc1sxXTtcbiAgdmFyIGR4ID0gQi5jbGllbnRYIC0gQS5jbGllbnRYO1xuICB2YXIgZHkgPSBCLmNsaWVudFkgLSBBLmNsaWVudFk7XG4gIHZhciBjeCA9IChCLmNsaWVudFggKyBBLmNsaWVudFgpIC8gMjtcbiAgdmFyIGN5ID0gKEIuY2xpZW50WSArIEEuY2xpZW50WSkgLyAyO1xuICB2YXIgZSA9ICduYXRpdmVFdmVudCcgaW4gZXZlbnQgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50O1xuICB2YXIgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGR4LCBkeSk7XG4gIHZhciBhbmdsZSA9IChfZSRyb3RhdGlvbiA9IGUucm90YXRpb24pICE9IG51bGwgPyBfZSRyb3RhdGlvbiA6IC0oTWF0aC5hdGFuMihkeCwgZHkpICogMTgwKSAvIE1hdGguUEk7XG4gIHZhciB2YWx1ZXMgPSBbZGlzdGFuY2UsIGFuZ2xlXTtcbiAgdmFyIG9yaWdpbiA9IFtjeCwgY3ldO1xuICByZXR1cm4ge1xuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIG9yaWdpbjogb3JpZ2luXG4gIH07XG59XG5cbnZhciBUQVBfRElTVEFOQ0VfVEhSRVNIT0xEID0gMztcbnZhciBTV0lQRV9NQVhfRUxBUFNFRF9USU1FID0gMjIwO1xudmFyIERyYWdSZWNvZ25pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29vcmRpbmF0ZXNSZWNvZ25pemUpIHtcbiAgX2luaGVyaXRzTG9vc2UoRHJhZ1JlY29nbml6ZXIsIF9Db29yZGluYXRlc1JlY29nbml6ZSk7XG5cbiAgZnVuY3Rpb24gRHJhZ1JlY29nbml6ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29vcmRpbmF0ZXNSZWNvZ25pemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmluZ0tleSA9ICdkcmFnZ2luZyc7XG4gICAgX3RoaXMuc3RhdGVLZXkgPSAnZHJhZyc7XG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIGFkZCBiYWNrIHdoZW4gc2V0UG9pbnRlckNhcHR1cmUgaXMgd2lkZWx5IHd1cHBvcnRlZFxyXG4gICAgICogaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXNldFBvaW50ZXJDYXB0dXJlXHJcbiAgICAgKiBwcml2YXRlIHNldFBvaW50ZXJzID0gKGV2ZW50OiBVc2VHZXN0dXJlRXZlbnQ8UG9pbnRlckV2ZW50PikgPT4ge1xyXG4gICAgICogICBjb25zdCB7IGN1cnJlbnRUYXJnZXQsIHBvaW50ZXJJZCB9ID0gZXZlbnRcclxuICAgICAqICAgaWYgKGN1cnJlbnRUYXJnZXQpIGN1cnJlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkKVxyXG4gICAgICogICB0aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZSh7IGN1cnJlbnRUYXJnZXQsIHBvaW50ZXJJZCB9KVxyXG4gICAgICogfVxyXG4gICAgICAgICAgICAqIHByaXZhdGUgcmVtb3ZlUG9pbnRlcnMgPSAoKSA9PiB7XHJcbiAgICAgKiAgIGNvbnN0IHsgY3VycmVudFRhcmdldCwgcG9pbnRlcklkIH0gPSB0aGlzLnN0YXRlXHJcbiAgICAgKiAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIHBvaW50ZXJJZCkgY3VycmVudFRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUocG9pbnRlcklkKVxyXG4gICAgICogfVxyXG4gICAgICovXG5cbiAgICBfdGhpcy5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy5lbmFibGVkIHx8IF90aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUT0RPIGFkZCBiYWNrIHdoZW4gc2V0UG9pbnRlckNhcHR1cmUgaXMgd2lkZWx5IHN1cHBvcnRlZFxyXG4gICAgICAgKiB0aGlzLnNldFBvaW50ZXJzKGV2ZW50IGFzIFBvaW50ZXJFdmVudClcclxuICAgICAgICovXG5cbiAgICAgIHVwZGF0ZVdpbmRvd0xpc3RlbmVycyhfdGhpcy5jb250cm9sbGVyLCBfdGhpcy5zdGF0ZUtleSwgW1sncG9pbnRlcm1vdmUnLCBfdGhpcy5vbkRyYWdDaGFuZ2VdLCBbJ3BvaW50ZXJ1cCcsIF90aGlzLm9uRHJhZ0VuZF0sIFsncG9pbnRlcmNhbmNlbCcsIF90aGlzLm9uRHJhZ0VuZF1dKTsgLy8gV2Ugc2V0IHRoZSBzdGF0ZSBwb2ludGVySWQgdG8gdGhlIGV2ZW50LnBvaW50ZXJJZCBzbyB3ZSBjYW4gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IHdlIGxvY2sgdGhlIGRyYWcgdG8gdGhlIGV2ZW50IGluaXRpYXRpbmcgdGhlIGdlc3R1cmVcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKHtcbiAgICAgICAgX3BvaW50ZXJJZDogZXZlbnQucG9pbnRlcklkXG4gICAgICB9KTtcblxuICAgICAgaWYgKF90aGlzLmNvbmZpZy5kZWxheSA+IDApIHtcbiAgICAgICAgX3RoaXMuc3RhdGUuX2RlbGF5ZWRFdmVudCA9IHRydWU7IC8vIElmIGl0J3MgYSBSZWFjdCBTeW50aGV0aWNFdmVudCB3ZSBuZWVkIHRvIHBlcnNpc3QgaXQgc28gdGhhdCB3ZSBjYW4gdXNlIGl0IGFzeW5jXG5cbiAgICAgICAgaWYgKCdwZXJzaXN0JyBpbiBldmVudCAmJiB0eXBlb2YgZXZlbnQucGVyc2lzdCA9PT0gJ2Z1bmN0aW9uJykgZXZlbnQucGVyc2lzdCgpO1xuXG4gICAgICAgIF90aGlzLnNldFRpbWVvdXQoX3RoaXMuc3RhcnREcmFnLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBfdGhpcy5jb25maWcuZGVsYXksIGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnN0YXJ0RHJhZyhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRHJhZ0NoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgdGhlIGdlc3R1cmUgd2FzIGNhbmNlbGVkIGRvbid0IHJlc3BvbmQgdG8gdGhlIGV2ZW50LlxuICAgICAgaWYgKF90aGlzLnN0YXRlLmNhbmNlbGVkKSByZXR1cm47IC8vIElmIHRoZSBldmVudCBwb2ludGVySWQgZG9lc24ndCBtYXRjaCB0aGUgaW5pdGlhdGluZyBwb2ludGVySWRcbiAgICAgIC8vIGRvbid0IHJlc3BvbmQgdG8gdGhlIGV2ZW50LlxuXG4gICAgICBpZiAoZXZlbnQucG9pbnRlcklkICE9PSBfdGhpcy5zdGF0ZS5fcG9pbnRlcklkKSByZXR1cm47IC8vIElmIHRoZSBnZXN0dXJlIGlzbid0IGFjdGl2ZSB0aGVuIHJlc3BvbmQgdG8gdGhlIGV2ZW50IG9ubHkgaWZcbiAgICAgIC8vIGl0J3MgYmVlbiBkZWxheWVkIHZpYSB0aGUgYGRlbGF5YCBvcHRpb24sIGluIHdoaWNoIGNhc2Ugc3RhcnRcbiAgICAgIC8vIHRoZSBnZXN0dXJlIGltbWVkaWF0ZWx5LlxuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLl9hY3RpdmUpIHtcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlLl9kZWxheWVkRXZlbnQpIHtcbiAgICAgICAgICBfdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICAgIF90aGlzLnN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBnZW5lcmljRXZlbnREYXRhID0gZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCk7IC8vIElmIHRoZSBldmVudCBkb2Vzbid0IGhhdmUgYW55IGJ1dHRvbiAvIHRvdWNoZXMgbGVmdCB3ZSBzaG91bGQgY2FuY2VsXG4gICAgICAvLyB0aGUgZ2VzdHVyZS4gVGhpcyBtYXkgaGFwcGVuIGlmIHRoZSBkcmFnIHJlbGVhc2UgaGFwcGVucyBvdXRzaWRlIHRoZSBicm93c2VyXG4gICAgICAvLyB3aW5kb3cuXG5cbiAgICAgIGlmICghZ2VuZXJpY0V2ZW50RGF0YS5kb3duKSB7XG4gICAgICAgIF90aGlzLm9uRHJhZ0VuZChldmVudCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZW5lcmljRXZlbnREYXRhKTtcblxuICAgICAgdmFyIHZhbHVlcyA9IGdldFBvaW50ZXJFdmVudFZhbHVlcyhldmVudCk7XG5cbiAgICAgIHZhciBraW5lbWF0aWNzID0gX3RoaXMuZ2V0S2luZW1hdGljcyh2YWx1ZXMsIGV2ZW50KTtcblxuICAgICAgdmFyIGdlbmVyaWNQYXlsb2FkID0gZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KTsgLy8gVGhpcyB2ZXJpZmllcyBpZiB0aGUgZHJhZyBjYW4gYmUgYXNzaW1pbGF0ZWQgdG8gYSB0YXAgYnkgY2hlY2tpbmdcbiAgICAgIC8vIGlmIHRoZSByZWFsIGRpc3RhbmNlIG9mIHRoZSBkcmFnIChpZSBub3QgYWNjb3VudGluZyBmb3IgdGhlIHRocmVzaG9sZCkgaXNcbiAgICAgIC8vIGdyZWF0ZXIgdGhhbiB0aGUgVEFQX0RJU1RBTkNFX1RIUkVTSE9MRC5cblxuICAgICAgdmFyIF9pc1RhcCA9IF90aGlzLnN0YXRlLl9pc1RhcDtcbiAgICAgIHZhciByZWFsRGlzdGFuY2UgPSBjYWxjdWxhdGVEaXN0YW5jZShraW5lbWF0aWNzLl9tb3ZlbWVudCk7XG4gICAgICBpZiAoX2lzVGFwICYmIHJlYWxEaXN0YW5jZSA+PSBUQVBfRElTVEFOQ0VfVEhSRVNIT0xEKSBfaXNUYXAgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZW5lcmljUGF5bG9hZCwga2luZW1hdGljcywge1xuICAgICAgICBfaXNUYXA6IF9pc1RhcFxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgcG9pbnRlcklkIGRvZXNuJ3QgbWF0Y2ggdGhlIGluaXRpYXRpbmcgcG9pbnRlcklkXG4gICAgICAvLyBkb24ndCByZXNwb25kIHRvIHRoZSBldmVudC5cbiAgICAgIGlmIChldmVudC5wb2ludGVySWQgIT09IF90aGlzLnN0YXRlLl9wb2ludGVySWQpIHJldHVybjtcbiAgICAgIF90aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoe1xuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgYnV0dG9uczogMCxcbiAgICAgICAgdG91Y2hlczogMFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0YXAgPSBfdGhpcy5zdGF0ZS5faXNUYXA7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUkdmVsb2NpdGllID0gX3RoaXMuc3RhdGUudmVsb2NpdGllcyxcbiAgICAgICAgICB2eCA9IF90aGlzJHN0YXRlJHZlbG9jaXRpZVswXSxcbiAgICAgICAgICB2eSA9IF90aGlzJHN0YXRlJHZlbG9jaXRpZVsxXTtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSRtb3ZlbWVudCA9IF90aGlzLnN0YXRlLm1vdmVtZW50LFxuICAgICAgICAgIG14ID0gX3RoaXMkc3RhdGUkbW92ZW1lbnRbMF0sXG4gICAgICAgICAgbXkgPSBfdGhpcyRzdGF0ZSRtb3ZlbWVudFsxXTtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSRfaW50ZW50aW8gPSBfdGhpcy5zdGF0ZS5faW50ZW50aW9uYWwsXG4gICAgICAgICAgaXggPSBfdGhpcyRzdGF0ZSRfaW50ZW50aW9bMF0sXG4gICAgICAgICAgaXkgPSBfdGhpcyRzdGF0ZSRfaW50ZW50aW9bMV07XG4gICAgICB2YXIgX3RoaXMkY29uZmlnJHN3aXBlVmVsID0gX3RoaXMuY29uZmlnLnN3aXBlVmVsb2NpdHksXG4gICAgICAgICAgc3Z4ID0gX3RoaXMkY29uZmlnJHN3aXBlVmVsWzBdLFxuICAgICAgICAgIHN2eSA9IF90aGlzJGNvbmZpZyRzd2lwZVZlbFsxXTtcbiAgICAgIHZhciBfdGhpcyRjb25maWckc3dpcGVEaXMgPSBfdGhpcy5jb25maWcuc3dpcGVEaXN0YW5jZSxcbiAgICAgICAgICBzeCA9IF90aGlzJGNvbmZpZyRzd2lwZURpc1swXSxcbiAgICAgICAgICBzeSA9IF90aGlzJGNvbmZpZyRzd2lwZURpc1sxXTtcblxuICAgICAgdmFyIGVuZFN0YXRlID0gX2V4dGVuZHMoe30sIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCksIF90aGlzLmdldE1vdmVtZW50KF90aGlzLnN0YXRlLnZhbHVlcykpO1xuXG4gICAgICB2YXIgc3dpcGUgPSBbMCwgMF07XG5cbiAgICAgIGlmIChlbmRTdGF0ZS5lbGFwc2VkVGltZSA8IFNXSVBFX01BWF9FTEFQU0VEX1RJTUUpIHtcbiAgICAgICAgaWYgKGl4ICE9PSBmYWxzZSAmJiBNYXRoLmFicyh2eCkgPiBzdnggJiYgTWF0aC5hYnMobXgpID4gc3gpIHN3aXBlWzBdID0gc2lnbih2eCk7XG4gICAgICAgIGlmIChpeSAhPT0gZmFsc2UgJiYgTWF0aC5hYnModnkpID4gc3Z5ICYmIE1hdGguYWJzKG15KSA+IHN5KSBzd2lwZVsxXSA9IHNpZ24odnkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGVuZFN0YXRlLCB7XG4gICAgICAgIHRhcDogdGFwLFxuICAgICAgICBzd2lwZTogc3dpcGVcbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKHRhcCA9PT0gdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgX0Nvb3JkaW5hdGVzUmVjb2duaXplLnByb3RvdHlwZS5jbGVhbi5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgICAgX3RoaXMuc3RhdGUuX2RlbGF5ZWRFdmVudCA9IGZhbHNlOyAvLyBjYW4ndCByZW1lbWJlciBpZiB0aGlzIGlzIHVzZWZ1bD9cblxuICAgICAgY2xlYXJXaW5kb3dMaXN0ZW5lcnMoX3RoaXMuY29udHJvbGxlciwgX3RoaXMuc3RhdGVLZXkpOyAvLyBUT0RPIGFkZCBiYWNrIHdoZW4gc2V0UG9pbnRlckNhcHR1cmUgaXMgd2lkZWx5IHd1cHBvcnRlZFxuICAgICAgLy8gdGhpcy5yZW1vdmVQb2ludGVycygpXG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnN0YXRlLmNhbmNlbGVkKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZSh7XG4gICAgICAgIGNhbmNlbGVkOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZSh7XG4gICAgICAgIGRvd246IGZhbHNlLFxuICAgICAgICBidXR0b25zOiAwLFxuICAgICAgICB0b3VjaGVzOiAwXG4gICAgICB9KTtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMuc3RhdGUuX2lzVGFwKSBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERyYWdSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc3RhcnREcmFnID0gZnVuY3Rpb24gc3RhcnREcmFnKGV2ZW50KSB7XG4gICAgdmFyIHZhbHVlcyA9IGdldFBvaW50ZXJFdmVudFZhbHVlcyhldmVudCk7XG4gICAgdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG4gICAgdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldFN0YXJ0R2VzdHVyZVN0YXRlKHRoaXMsIHZhbHVlcywgZXZlbnQpLCBnZXRHZW5lcmljUGF5bG9hZCh0aGlzLCBldmVudCwgdHJ1ZSksIHtcbiAgICAgIF9wb2ludGVySWQ6IGV2ZW50LnBvaW50ZXJJZCxcbiAgICAgIGNhbmNlbDogdGhpcy5vbkNhbmNlbFxuICAgIH0pKTtcbiAgICB0aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZSh0aGlzLmdldE1vdmVtZW50KHZhbHVlcykpO1xuICAgIHRoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLmFkZEJpbmRpbmdzID0gZnVuY3Rpb24gYWRkQmluZGluZ3MkMShiaW5kaW5ncykge1xuICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Qb2ludGVyRG93bicsIHRoaXMub25EcmFnU3RhcnQpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmZpbHRlclRhcHMpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5jb250cm9sbGVyLmNvbmZpZy5ldmVudE9wdGlvbnMuY2FwdHVyZSA/ICdvbkNsaWNrJyA6ICdvbkNsaWNrQ2FwdHVyZSc7XG5cbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCBoYW5kbGVyLCB0aGlzLm9uQ2xpY2spO1xuICAgIH0gLy8gVE9ETyBhZGQgYmFjayB3aGVuIHNldFBvaW50ZXJDYXB0dXJlIGlzIHdpZGVseSB3dXBwb3J0ZWRcbiAgICAvLyBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uUG9pbnRlck1vdmUnLCB0aGlzLm9uRHJhZ0NoYW5nZSlcbiAgICAvLyBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uUG9pbnRlclVwJywgdGhpcy5vbkRyYWdFbmQpXG4gICAgLy8gYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblBvaW50ZXJDYW5jZWwnLCB0aGlzLm9uRHJhZ0VuZClcblxuICB9O1xuXG4gIHJldHVybiBEcmFnUmVjb2duaXplcjtcbn0oQ29vcmRpbmF0ZXNSZWNvZ25pemVyKTtcblxuLyoqXHJcbiAqIElubGluZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWxleHJlYXJkb24vbWVtb2l6ZS1vbmVcclxuICovXG5mdW5jdGlvbiBtZW1vaXplT25lKHJlc3VsdEZuLCBpc0VxdWFsKSB7XG4gIHZhciBsYXN0VGhpcztcbiAgdmFyIGxhc3RBcmdzID0gW107XG4gIHZhciBsYXN0UmVzdWx0O1xuICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdBcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbmV3QXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGVkT25jZSAmJiBsYXN0VGhpcyA9PT0gdGhpcyAmJiBpc0VxdWFsKG5ld0FyZ3MsIGxhc3RBcmdzKSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgbGFzdFJlc3VsdCA9IHJlc3VsdEZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0QXJncyA9IG5ld0FyZ3M7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8qKlxyXG4gKiBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9Gb3JtaWRhYmxlTGFicy9yZWFjdC1mYXN0LWNvbXBhcmVcclxuICpcclxuICogRHJvcHBlZCBjb21tZW50cyBhbmQgQXJyYXlCdWZmZXIgaGFuZGxpbmdcclxuICovXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGl0O1xuXG4gICAgaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgYSBpbnN0YW5jZW9mIE1hcCAmJiBiIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAgIGl0ID0gYS5lbnRyaWVzKCk7XG5cbiAgICAgIHdoaWxlICghKGkgPSBpdC5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpLnZhbHVlWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpdCA9IGEuZW50cmllcygpO1xuXG4gICAgICB3aGlsZSAoIShpID0gaXQubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGlmICghZXF1YWwoaS52YWx1ZVsxXSwgYi5nZXQoaS52YWx1ZVswXSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGEgaW5zdGFuY2VvZiBTZXQgJiYgYiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICBpdCA9IGEuZW50cmllcygpO1xuXG4gICAgICB3aGlsZSAoIShpID0gaXQubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGlmICghYi5oYXMoaS52YWx1ZVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGEgaW5zdGFuY2VvZiBFbGVtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmIChrZXlzW2ldID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSBjb250aW51ZTtcbiAgICAgIGlmICghZXF1YWwoYVtrZXlzW2ldXSwgYltrZXlzW2ldXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2Ug4oCUIE5hTiAhPT0gTmFOIOKGkiB0cnVlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuXG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICB0cnkge1xuICAgIHJldHVybiBlcXVhbChhLCBiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoKGVycm9yLm1lc3NhZ2UgfHwgJycpLm1hdGNoKC9zdGFja3xyZWN1cnNpb24vaSkpIHtcbiAgICAgIGNvbnNvbGUud2FybigncmVhY3QtZmFzdC1jb21wYXJlIGNhbm5vdCBoYW5kbGUgY2lyY3VsYXIgcmVmcycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxyXG4gKiBEcmFnIGhvb2suXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyIC0gdGhlIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIGRyYWcgZ2VzdHVyZSB1cGRhdGVzXHJcbiAqIEBwYXJhbSBbY29uZmlnPXt9XSAtIHRoZSBjb25maWcgb2JqZWN0IGluY2x1ZGluZyBnZW5lcmljIG9wdGlvbnMgYW5kIGRyYWcgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gdXNlRHJhZyhoYW5kbGVyLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBSZWNvZ25pemVyc01hcC5zZXQoJ2RyYWcnLCBEcmFnUmVjb2duaXplcik7XG4gIHZhciBidWlsZERyYWdDb25maWcgPSB1c2VSZWYoKTtcblxuICBpZiAoIWJ1aWxkRHJhZ0NvbmZpZy5jdXJyZW50KSB7XG4gICAgYnVpbGREcmFnQ29uZmlnLmN1cnJlbnQgPSBtZW1vaXplT25lKF9idWlsZERyYWdDb25maWcsIGlzRXF1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlY29nbml6ZXJzKHtcbiAgICBkcmFnOiBoYW5kbGVyXG4gIH0sIGJ1aWxkRHJhZ0NvbmZpZy5jdXJyZW50KGNvbmZpZykpO1xufVxuXG4vKipcclxuICogQHByaXZhdGVcclxuICogQWJzdHJhY3QgY2xhc3MgZm9yIGRpc3RhbmNlL2FuZ2xlLWJhc2VkIGdlc3R1cmUgcmVjb25naXplcnNcclxuICovXG5cbnZhciBEaXN0YW5jZUFuZ2xlUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRGlzdGFuY2VBbmdsZVJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBEaXN0YW5jZUFuZ2xlUmVjb2duaXplcigpIHtcbiAgICByZXR1cm4gX1JlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERpc3RhbmNlQW5nbGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0SW50ZXJuYWxNb3ZlbWVudCA9IGZ1bmN0aW9uIGdldEludGVybmFsTW92ZW1lbnQodmFsdWVzLCBzdGF0ZSkge1xuICAgIHZhciBwcmV2X2EgPSBzdGF0ZS52YWx1ZXNbMV07IC8vIG5vdCBiZSBkZWZpbmVkIGlmIGN0cmwrd2hlZWwgaXMgdXNlZCBmb3Igem9vbSBvbmx5XG5cbiAgICB2YXIgZCA9IHZhbHVlc1swXSxcbiAgICAgICAgX3ZhbHVlcyQgPSB2YWx1ZXNbMV0sXG4gICAgICAgIGEgPSBfdmFsdWVzJCA9PT0gdm9pZCAwID8gcHJldl9hIDogX3ZhbHVlcyQ7XG4gICAgdmFyIGRlbHRhX2EgPSBhIC0gcHJldl9hO1xuICAgIHZhciBuZXh0X3R1cm5zID0gc3RhdGUudHVybnM7XG4gICAgaWYgKE1hdGguYWJzKGRlbHRhX2EpID4gMjcwKSBuZXh0X3R1cm5zICs9IHNpZ24oZGVsdGFfYSk7XG4gICAgcmV0dXJuIHN1YlYoW2QsIGEgLSAzNjAgKiBuZXh0X3R1cm5zXSwgc3RhdGUuaW5pdGlhbCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEtpbmVtYXRpY3MgPSBmdW5jdGlvbiBnZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmdldE1vdmVtZW50KHZhbHVlcyk7XG4gICAgdmFyIHR1cm5zID0gKHZhbHVlc1sxXSAtIHN0YXRlLm1vdmVtZW50WzFdIC0gdGhpcy5zdGF0ZS5pbml0aWFsWzFdKSAvIDM2MDtcbiAgICB2YXIgZHQgPSBldmVudC50aW1lU3RhbXAgLSB0aGlzLnN0YXRlLnRpbWVTdGFtcDtcbiAgICB2YXIga2luZW1hdGljcyA9IGNhbGN1bGF0ZUFsbEtpbmVtYXRpY3Moc3RhdGUubW92ZW1lbnQsIHN0YXRlLmRlbHRhLCBkdCk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHR1cm5zOiB0dXJuc1xuICAgIH0sIHN0YXRlLCBraW5lbWF0aWNzKTtcbiAgfTtcblxuICBfcHJvdG8ubWFwU3RhdGVWYWx1ZXMgPSBmdW5jdGlvbiBtYXBTdGF0ZVZhbHVlcyhzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYTogc3RhdGUudmFsdWVzLFxuICAgICAgdmR2YTogc3RhdGUudmVsb2NpdGllc1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIERpc3RhbmNlQW5nbGVSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcblxudmFyIFBpbmNoUmVjb2duaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Rpc3RhbmNlQW5nbGVSZWNvZ25pKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBpbmNoUmVjb2duaXplciwgX0Rpc3RhbmNlQW5nbGVSZWNvZ25pKTtcblxuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRGlzdGFuY2VBbmdsZVJlY29nbmkuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmluZ0tleSA9ICdwaW5jaGluZyc7XG4gICAgX3RoaXMuc3RhdGVLZXkgPSAncGluY2gnO1xuXG4gICAgX3RoaXMucGluY2hTaG91bGRTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF9nZXRHZW5lcmljRXZlbnREYXRhID0gZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCksXG4gICAgICAgICAgdG91Y2hlcyA9IF9nZXRHZW5lcmljRXZlbnREYXRhLnRvdWNoZXM7XG5cbiAgICAgIHJldHVybiBfdGhpcy5lbmFibGVkICYmIHRvdWNoZXMgPT09IDI7XG4gICAgfTtcblxuICAgIF90aGlzLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy5waW5jaFNob3VsZFN0YXJ0KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2dldFR3b1RvdWNoZXNFdmVudERhID0gZ2V0VHdvVG91Y2hlc0V2ZW50RGF0YShldmVudCksXG4gICAgICAgICAgdmFsdWVzID0gX2dldFR3b1RvdWNoZXNFdmVudERhLnZhbHVlcyxcbiAgICAgICAgICBvcmlnaW4gPSBfZ2V0VHdvVG91Y2hlc0V2ZW50RGEub3JpZ2luO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0U3RhcnRHZXN0dXJlU3RhdGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhbHVlcywgZXZlbnQpLCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQsIHRydWUpLCB7XG4gICAgICAgIGNhbmNlbDogX3RoaXMub25DYW5jZWwsXG4gICAgICAgIG9yaWdpbjogb3JpZ2luXG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfdGhpcy5nZXRNb3ZlbWVudCh2YWx1ZXMpKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uUGluY2hDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGNhbmNlbGVkID0gX3RoaXMkc3RhdGUuY2FuY2VsZWQsXG4gICAgICAgICAgX2FjdGl2ZSA9IF90aGlzJHN0YXRlLl9hY3RpdmU7XG4gICAgICBpZiAoY2FuY2VsZWQgfHwgIV9hY3RpdmUpIHJldHVybjtcbiAgICAgIHZhciBnZW5lcmljRXZlbnREYXRhID0gZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdlbmVyaWNFdmVudERhdGEpO1xuXG4gICAgICB2YXIgX2dldFR3b1RvdWNoZXNFdmVudERhMiA9IGdldFR3b1RvdWNoZXNFdmVudERhdGEoZXZlbnQpLFxuICAgICAgICAgIHZhbHVlcyA9IF9nZXRUd29Ub3VjaGVzRXZlbnREYTIudmFsdWVzLFxuICAgICAgICAgIG9yaWdpbiA9IF9nZXRUd29Ub3VjaGVzRXZlbnREYTIub3JpZ2luOyAvLyBAdHMtaWdub3JlXG5cblxuICAgICAgdmFyIGtpbmVtYXRpY3MgPSBfdGhpcy5nZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCksIGtpbmVtYXRpY3MsIHtcbiAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uUGluY2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMuc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgICBfdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKHtcbiAgICAgICAgZG93bjogZmFsc2UsXG4gICAgICAgIHRvdWNoZXM6IDBcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCksIF90aGlzLmdldE1vdmVtZW50KF90aGlzLnN0YXRlLnZhbHVlcykpKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnN0YXRlLmNhbmNlbGVkKSByZXR1cm47XG4gICAgICBfdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZSh7XG4gICAgICAgIGNhbmNlbGVkOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoe1xuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlczogMFxuICAgICAgfSk7XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBQSU5DSCBXSVRIIFdFQktJVCBHRVNUVVJFU1xyXG4gICAgICovXG5cblxuICAgIF90aGlzLm9uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHVzZWxlc3NcblxuICAgICAgdmFyIHZhbHVlcyA9IGdldFdlYmtpdEdlc3R1cmVFdmVudFZhbHVlcyhldmVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNoYXJlZFN0YXRlKGdldEdlbmVyaWNFdmVudERhdGEoZXZlbnQpKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRTdGFydEdlc3R1cmVTdGF0ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFsdWVzLCBldmVudCksIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCwgdHJ1ZSksIHtcbiAgICAgICAgb3JpZ2luOiBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV0sXG4gICAgICAgIGNhbmNlbDogX3RoaXMub25DYW5jZWxcbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF90aGlzLmdldE1vdmVtZW50KHZhbHVlcykpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25HZXN0dXJlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgY2FuY2VsZWQgPSBfdGhpcyRzdGF0ZTIuY2FuY2VsZWQsXG4gICAgICAgICAgX2FjdGl2ZSA9IF90aGlzJHN0YXRlMi5fYWN0aXZlO1xuICAgICAgaWYgKGNhbmNlbGVkIHx8ICFfYWN0aXZlKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGdlbmVyaWNFdmVudERhdGEgPSBnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoZ2VuZXJpY0V2ZW50RGF0YSk7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSBnZXRXZWJraXRHZXN0dXJlRXZlbnRWYWx1ZXMoZXZlbnQpO1xuXG4gICAgICB2YXIga2luZW1hdGljcyA9IF90aGlzLmdldEtpbmVtYXRpY3ModmFsdWVzLCBldmVudCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwga2luZW1hdGljcywge1xuICAgICAgICBvcmlnaW46IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXVxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25HZXN0dXJlRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICAgIF90aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoe1xuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlczogMFxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwgX3RoaXMuZ2V0TW92ZW1lbnQoX3RoaXMuc3RhdGUudmFsdWVzKSwge1xuICAgICAgICBvcmlnaW46IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXVxuICAgICAgfSkpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogUElOQ0ggV0lUSCBXSEVFTFxyXG4gICAgICovXG5cblxuICAgIF90aGlzLndoZWVsU2hvdWxkUnVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW5hYmxlZCAmJiBldmVudC5jdHJsS2V5O1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRXaGVlbFZhbHVlc0Zyb21FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF9nZXRXaGVlbEV2ZW50VmFsdWVzID0gZ2V0V2hlZWxFdmVudFZhbHVlcyhldmVudCksXG4gICAgICAgICAgZGVsdGFfZCA9IF9nZXRXaGVlbEV2ZW50VmFsdWVzWzFdO1xuXG4gICAgICB2YXIgX3RoaXMkc3RhdGUkdmFsdWVzID0gX3RoaXMuc3RhdGUudmFsdWVzLFxuICAgICAgICAgIHByZXZfZCA9IF90aGlzJHN0YXRlJHZhbHVlc1swXSxcbiAgICAgICAgICBwcmV2X2EgPSBfdGhpcyRzdGF0ZSR2YWx1ZXNbMV07XG4gICAgICB2YXIgZCA9IHByZXZfZCAtIGRlbHRhX2Q7XG4gICAgICB2YXIgYSA9IHByZXZfYSAhPT0gdm9pZCAwID8gcHJldl9hIDogMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlczogW2QsIGFdLFxuICAgICAgICBvcmlnaW46IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXSxcbiAgICAgICAgZGVsdGE6IFswLCBkZWx0YV9kXVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25XaGVlbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy53aGVlbFNob3VsZFJ1bihldmVudCkpIHJldHVybjtcblxuICAgICAgX3RoaXMuc2V0VGltZW91dChfdGhpcy5vbldoZWVsRW5kKTtcblxuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5fYWN0aXZlKSBfdGhpcy5vbldoZWVsU3RhcnQoZXZlbnQpO2Vsc2UgX3RoaXMub25XaGVlbENoYW5nZShldmVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uV2hlZWxTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF90aGlzJGdldFdoZWVsVmFsdWVzRiA9IF90aGlzLmdldFdoZWVsVmFsdWVzRnJvbUV2ZW50KGV2ZW50KSxcbiAgICAgICAgICB2YWx1ZXMgPSBfdGhpcyRnZXRXaGVlbFZhbHVlc0YudmFsdWVzLFxuICAgICAgICAgIGRlbHRhID0gX3RoaXMkZ2V0V2hlZWxWYWx1ZXNGLmRlbHRhLFxuICAgICAgICAgIG9yaWdpbiA9IF90aGlzJGdldFdoZWVsVmFsdWVzRi5vcmlnaW47XG5cbiAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVG8gcHJvcGVybHkgc3VwcG9ydCB6b29tIG9uIHRyYWNrcGFkcywgdHJ5IHVzaW5nIHRoZSBgZG9tVGFyZ2V0YCBvcHRpb24gYW5kIGBjb25maWcuZXZlbnRPcHRpb25zLnBhc3NpdmVgIHNldCB0byBgZmFsc2VgLiBUaGlzIG1lc3NhZ2Ugd2lsbCBvbmx5IGFwcGVhciBpbiBkZXZlbG9wbWVudCBtb2RlLicpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0U3RhcnRHZXN0dXJlU3RhdGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhbHVlcywgZXZlbnQpLCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQsIHRydWUpLCB7XG4gICAgICAgIGluaXRpYWw6IF90aGlzLnN0YXRlLnZhbHVlcyxcbiAgICAgICAgb2Zmc2V0OiB2YWx1ZXMsXG4gICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF90aGlzLmdldE1vdmVtZW50KHZhbHVlcykpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25XaGVlbENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCkpO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0V2hlZWxWYWx1ZXNGMiA9IF90aGlzLmdldFdoZWVsVmFsdWVzRnJvbUV2ZW50KGV2ZW50KSxcbiAgICAgICAgICB2YWx1ZXMgPSBfdGhpcyRnZXRXaGVlbFZhbHVlc0YyLnZhbHVlcyxcbiAgICAgICAgICBvcmlnaW4gPSBfdGhpcyRnZXRXaGVlbFZhbHVlc0YyLm9yaWdpbixcbiAgICAgICAgICBkZWx0YSA9IF90aGlzJGdldFdoZWVsVmFsdWVzRjIuZGVsdGE7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwgX3RoaXMuZ2V0S2luZW1hdGljcyh2YWx1ZXMsIGV2ZW50KSwge1xuICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgZGVsdGE6IGRlbHRhXG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbldoZWVsRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX3RoaXMuZ2V0TW92ZW1lbnQoX3RoaXMuc3RhdGUudmFsdWVzKSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkQmluZGluZ3MgPSBmdW5jdGlvbiBhZGRCaW5kaW5ncyQxKGJpbmRpbmdzKSB7XG4gICAgLy8gT25seSB0cnkgdG8gdXNlIGdlc3R1cmUgZXZlbnRzIHdoZW4gdGhleSBhcmUgc3VwcG9ydGVkIGFuZCBkb21UYXJnZXQgaXMgc2V0XG4gICAgLy8gYXMgUmVhY3QgZG9lc24ndCBzdXBwb3J0IGdlc3R1cmUgaGFuZGxlcnMuXG4gICAgaWYgKHRoaXMuY29udHJvbGxlci5jb25maWcuZG9tVGFyZ2V0ICYmICFzdXBwb3J0c1RvdWNoRXZlbnRzKCkgJiYgc3VwcG9ydHNHZXN0dXJlRXZlbnRzKCkpIHtcbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25HZXN0dXJlU3RhcnQnLCB0aGlzLm9uR2VzdHVyZVN0YXJ0KTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvbkdlc3R1cmVDaGFuZ2UnLCB0aGlzLm9uR2VzdHVyZUNoYW5nZSk7XG5cbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25HZXN0dXJlRW5kJywgdGhpcy5vbkdlc3R1cmVFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uVG91Y2hTdGFydCcsIHRoaXMub25QaW5jaFN0YXJ0KTtcblxuICAgICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblRvdWNoTW92ZScsIHRoaXMub25QaW5jaENoYW5nZSk7XG5cbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Ub3VjaEVuZCcsIHRoaXMub25QaW5jaEVuZCk7XG5cbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Ub3VjaENhbmNlbCcsIHRoaXMub25QaW5jaEVuZCk7XG5cbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25XaGVlbCcsIHRoaXMub25XaGVlbCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQaW5jaFJlY29nbml6ZXI7XG59KERpc3RhbmNlQW5nbGVSZWNvZ25pemVyKTtcblxuLyoqXHJcbiAqIFBpbmNoIGhvb2suXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyIC0gdGhlIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIHBpbmNoIGdlc3R1cmUgdXBkYXRlc1xyXG4gKiBAcGFyYW0gW2NvbmZpZz17fV0gLSB0aGUgY29uZmlnIG9iamVjdCBpbmNsdWRpbmcgZ2VuZXJpYyBvcHRpb25zIGFuZCBwaW5jaCBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VQaW5jaChoYW5kbGVyLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBSZWNvZ25pemVyc01hcC5zZXQoJ3BpbmNoJywgUGluY2hSZWNvZ25pemVyKTtcbiAgdmFyIGJ1aWxkUGluY2hDb25maWcgPSB1c2VSZWYoKTtcblxuICBpZiAoIWJ1aWxkUGluY2hDb25maWcuY3VycmVudCkge1xuICAgIGJ1aWxkUGluY2hDb25maWcuY3VycmVudCA9IG1lbW9pemVPbmUoX2J1aWxkUGluY2hDb25maWcsIGlzRXF1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlY29nbml6ZXJzKHtcbiAgICBwaW5jaDogaGFuZGxlclxuICB9LCBidWlsZFBpbmNoQ29uZmlnLmN1cnJlbnQoY29uZmlnKSk7XG59XG5cbnZhciBXaGVlbFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db29yZGluYXRlc1JlY29nbml6ZSkge1xuICBfaW5oZXJpdHNMb29zZShXaGVlbFJlY29nbml6ZXIsIF9Db29yZGluYXRlc1JlY29nbml6ZSk7XG5cbiAgZnVuY3Rpb24gV2hlZWxSZWNvZ25pemVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Nvb3JkaW5hdGVzUmVjb2duaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5pbmdLZXkgPSAnd2hlZWxpbmcnO1xuICAgIF90aGlzLnN0YXRlS2V5ID0gJ3doZWVsJztcbiAgICBfdGhpcy5kZWJvdW5jZWQgPSB0cnVlO1xuXG4gICAgX3RoaXMuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmICdwaW5jaCcgaW4gX3RoaXMuY29udHJvbGxlci5oYW5kbGVycykgcmV0dXJuO1xuICAgICAgaWYgKCFfdGhpcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnNldFRpbWVvdXQoX3RoaXMub25FbmQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSBhZGRWKGdldFdoZWVsRXZlbnRWYWx1ZXMoZXZlbnQpLCBfdGhpcy5zdGF0ZS52YWx1ZXMpO1xuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLl9hY3RpdmUpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRTdGFydEdlc3R1cmVTdGF0ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFsdWVzLCBldmVudCksIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCwgdHJ1ZSksIHtcbiAgICAgICAgICBpbml0aWFsOiBfdGhpcy5zdGF0ZS52YWx1ZXNcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHZhciBtb3ZlbWVudCA9IF90aGlzLmdldE1vdmVtZW50KHZhbHVlcyk7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gY2FsY3VsYXRlQWxsR2VvbWV0cnkobW92ZW1lbnQuZGVsdGEpO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShtb3ZlbWVudCk7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKGdlb21ldHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfZXh0ZW5kcyh7fSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50KSwgX3RoaXMuZ2V0S2luZW1hdGljcyh2YWx1ZXMsIGV2ZW50KSkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbW92ZW1lbnQgPSBfdGhpcy5nZXRNb3ZlbWVudChfdGhpcy5zdGF0ZS52YWx1ZXMpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUobW92ZW1lbnQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoe1xuICAgICAgICBfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdmVsb2NpdGllczogWzAsIDBdLFxuICAgICAgICB2ZWxvY2l0eTogMFxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gV2hlZWxSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkQmluZGluZ3MgPSBmdW5jdGlvbiBhZGRCaW5kaW5ncyQxKGJpbmRpbmdzKSB7XG4gICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvbldoZWVsJywgdGhpcy5oYW5kbGVFdmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFdoZWVsUmVjb2duaXplcjtcbn0oQ29vcmRpbmF0ZXNSZWNvZ25pemVyKTtcblxuLyoqXHJcbiAqIFdoZWVsIGhvb2suXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyIC0gdGhlIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIHdoZWVsIGdlc3R1cmUgdXBkYXRlc1xyXG4gKiBAcGFyYW0gdGhlIGNvbmZpZyBvYmplY3QgaW5jbHVkaW5nIGdlbmVyaWMgb3B0aW9ucyBhbmQgd2hlZWwgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gdXNlV2hlZWwoaGFuZGxlciwgY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgUmVjb2duaXplcnNNYXAuc2V0KCd3aGVlbCcsIFdoZWVsUmVjb2duaXplcik7XG4gIHZhciBidWlsZFdoZWVsQ29uZmlnID0gdXNlUmVmKCk7XG5cbiAgaWYgKCFidWlsZFdoZWVsQ29uZmlnLmN1cnJlbnQpIHtcbiAgICBidWlsZFdoZWVsQ29uZmlnLmN1cnJlbnQgPSBtZW1vaXplT25lKF9idWlsZFdoZWVsQ29uZmlnLCBpc0VxdWFsKTtcbiAgfVxuXG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgd2hlZWw6IGhhbmRsZXJcbiAgfSwgYnVpbGRXaGVlbENvbmZpZy5jdXJyZW50KGNvbmZpZykpO1xufVxuXG52YXIgTW92ZVJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db29yZGluYXRlc1JlY29nbml6ZSkge1xuICBfaW5oZXJpdHNMb29zZShNb3ZlUmVjb2duaXplciwgX0Nvb3JkaW5hdGVzUmVjb2duaXplKTtcblxuICBmdW5jdGlvbiBNb3ZlUmVjb2duaXplcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db29yZGluYXRlc1JlY29nbml6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaW5nS2V5ID0gJ21vdmluZyc7XG4gICAgX3RoaXMuc3RhdGVLZXkgPSAnbW92ZSc7XG4gICAgX3RoaXMuZGVib3VuY2VkID0gdHJ1ZTtcblxuICAgIF90aGlzLm9uTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFfdGhpcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnNldFRpbWVvdXQoX3RoaXMub25Nb3ZlRW5kKTtcblxuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5fYWN0aXZlKSBfdGhpcy5vbk1vdmVTdGFydChldmVudCk7ZWxzZSBfdGhpcy5vbk1vdmVDaGFuZ2UoZXZlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdmVTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMudXBkYXRlU2hhcmVkU3RhdGUoZ2V0R2VuZXJpY0V2ZW50RGF0YShldmVudCkpO1xuXG4gICAgICB2YXIgdmFsdWVzID0gZ2V0UG9pbnRlckV2ZW50VmFsdWVzKGV2ZW50KTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRTdGFydEdlc3R1cmVTdGF0ZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFsdWVzLCBldmVudCksIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCwgdHJ1ZSkpKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF90aGlzLmdldE1vdmVtZW50KHZhbHVlcykpO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Nb3ZlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIHZhciB2YWx1ZXMgPSBnZXRQb2ludGVyRXZlbnRWYWx1ZXMoZXZlbnQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCksIF90aGlzLmdldEtpbmVtYXRpY3ModmFsdWVzLCBldmVudCkpKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uTW92ZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBfdGhpcy5zdGF0ZS52YWx1ZXM7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUdlc3R1cmVTdGF0ZShfdGhpcy5nZXRNb3ZlbWVudCh2YWx1ZXMpKTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKHtcbiAgICAgICAgdmVsb2NpdGllczogWzAsIDBdLFxuICAgICAgICB2ZWxvY2l0eTogMCxcbiAgICAgICAgX2FjdGl2ZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5maXJlR2VzdHVyZUhhbmRsZXIoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Qb2ludGVyRW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLmNvbnRyb2xsZXIuc3RhdGUuc2hhcmVkLmhvdmVyaW5nID0gdHJ1ZTtcbiAgICAgIGlmICghX3RoaXMuY29udHJvbGxlci5jb25maWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoX3RoaXMuY29udHJvbGxlci5jb25maWcuaG92ZXIuZW5hYmxlZCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0UG9pbnRlckV2ZW50VmFsdWVzKGV2ZW50KTtcblxuICAgICAgICB2YXIgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgX3RoaXMuY29udHJvbGxlci5zdGF0ZS5zaGFyZWQsIF90aGlzLnN0YXRlLCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQsIHRydWUpLCB7XG4gICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGhvdmVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzLmNvbnRyb2xsZXIuaGFuZGxlcnMuaG92ZXIoX2V4dGVuZHMoe30sIHN0YXRlLCBfdGhpcy5tYXBTdGF0ZVZhbHVlcyhzdGF0ZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdtb3ZlJyBpbiBfdGhpcy5jb250cm9sbGVyLmhhbmRsZXJzKSBfdGhpcy5vbk1vdmVTdGFydChldmVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uUG9pbnRlckxlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5jb250cm9sbGVyLnN0YXRlLnNoYXJlZC5ob3ZlcmluZyA9IGZhbHNlO1xuICAgICAgaWYgKCdtb3ZlJyBpbiBfdGhpcy5jb250cm9sbGVyLmhhbmRsZXJzKSBfdGhpcy5vbk1vdmVFbmQoKTtcbiAgICAgIGlmICghX3RoaXMuY29udHJvbGxlci5jb25maWcuaG92ZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdmFyIHZhbHVlcyA9IGdldFBvaW50ZXJFdmVudFZhbHVlcyhldmVudCk7XG5cbiAgICAgIHZhciBzdGF0ZSA9IF9leHRlbmRzKHt9LCBfdGhpcy5jb250cm9sbGVyLnN0YXRlLnNoYXJlZCwgX3RoaXMuc3RhdGUsIGdldEdlbmVyaWNQYXlsb2FkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBldmVudCksIHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5jb250cm9sbGVyLmhhbmRsZXJzLmhvdmVyKF9leHRlbmRzKHt9LCBzdGF0ZSwgX3RoaXMubWFwU3RhdGVWYWx1ZXMoc3RhdGUpKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNb3ZlUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZEJpbmRpbmdzID0gZnVuY3Rpb24gYWRkQmluZGluZ3MkMShiaW5kaW5ncykge1xuICAgIGlmICgnbW92ZScgaW4gdGhpcy5jb250cm9sbGVyLmhhbmRsZXJzKSB7XG4gICAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uUG9pbnRlck1vdmUnLCB0aGlzLm9uTW92ZSk7XG4gICAgfVxuXG4gICAgaWYgKCdob3ZlcicgaW4gdGhpcy5jb250cm9sbGVyLmhhbmRsZXJzKSB7XG4gICAgICBhZGRCaW5kaW5ncyhiaW5kaW5ncywgJ29uUG9pbnRlckVudGVyJywgdGhpcy5vblBvaW50ZXJFbnRlcik7XG5cbiAgICAgIGFkZEJpbmRpbmdzKGJpbmRpbmdzLCAnb25Qb2ludGVyTGVhdmUnLCB0aGlzLm9uUG9pbnRlckxlYXZlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1vdmVSZWNvZ25pemVyO1xufShDb29yZGluYXRlc1JlY29nbml6ZXIpO1xuXG4vKipcclxuICogTW92ZSBob29rLlxyXG4gKlxyXG4gKiBAcGFyYW0gaGFuZGxlciAtIHRoZSBmdW5jdGlvbiBmaXJlZCBldmVyeSB0aW1lIHRoZSBtb3ZlIGdlc3R1cmUgdXBkYXRlc1xyXG4gKiBAcGFyYW0gW2NvbmZpZz17fV0gLSB0aGUgY29uZmlnIG9iamVjdCBpbmNsdWRpbmcgZ2VuZXJpYyBvcHRpb25zIGFuZCBtb3ZlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIHVzZU1vdmUoaGFuZGxlciwgY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgUmVjb2duaXplcnNNYXAuc2V0KCdtb3ZlJywgTW92ZVJlY29nbml6ZXIpO1xuICB2YXIgYnVpbGRNb3ZlQ29uZmlnID0gdXNlUmVmKCk7XG5cbiAgaWYgKCFidWlsZE1vdmVDb25maWcuY3VycmVudCkge1xuICAgIGJ1aWxkTW92ZUNvbmZpZy5jdXJyZW50ID0gbWVtb2l6ZU9uZShfYnVpbGRNb3ZlQ29uZmlnLCBpc0VxdWFsKTtcbiAgfVxuXG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgbW92ZTogaGFuZGxlclxuICB9LCBidWlsZE1vdmVDb25maWcuY3VycmVudChjb25maWcpKTtcbn1cblxuLyoqXHJcbiAqIEhvdmVyIGhvb2suXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyIC0gdGhlIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIGhvdmVyIGdlc3R1cmUgdXBkYXRlc1xyXG4gKiBAcGFyYW0gW2NvbmZpZz17fV0gLSB0aGUgY29uZmlnIG9iamVjdCBpbmNsdWRpbmcgZ2VuZXJpYyBvcHRpb25zIGFuZCBob3ZlciBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VIb3ZlcihoYW5kbGVyLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBSZWNvZ25pemVyc01hcC5zZXQoJ2hvdmVyJywgTW92ZVJlY29nbml6ZXIpO1xuICB2YXIgYnVpbGRIb3ZlckNvbmZpZyA9IHVzZVJlZigpO1xuXG4gIGlmICghYnVpbGRIb3ZlckNvbmZpZy5jdXJyZW50KSB7XG4gICAgYnVpbGRIb3ZlckNvbmZpZy5jdXJyZW50ID0gbWVtb2l6ZU9uZShfYnVpbGRIb3ZlckNvbmZpZywgaXNFcXVhbCk7XG4gIH1cblxuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIGhvdmVyOiBoYW5kbGVyXG4gIH0sIGJ1aWxkSG92ZXJDb25maWcuY3VycmVudChjb25maWcpKTtcbn1cblxudmFyIFNjcm9sbFJlY29nbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db29yZGluYXRlc1JlY29nbml6ZSkge1xuICBfaW5oZXJpdHNMb29zZShTY3JvbGxSZWNvZ25pemVyLCBfQ29vcmRpbmF0ZXNSZWNvZ25pemUpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbFJlY29nbml6ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29vcmRpbmF0ZXNSZWNvZ25pemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmluZ0tleSA9ICdzY3JvbGxpbmcnO1xuICAgIF90aGlzLnN0YXRlS2V5ID0gJ3Njcm9sbCc7XG4gICAgX3RoaXMuZGVib3VuY2VkID0gdHJ1ZTtcblxuICAgIF90aGlzLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV90aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgX3RoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgIF90aGlzLnNldFRpbWVvdXQoX3RoaXMub25FbmQpO1xuXG4gICAgICB2YXIgdmFsdWVzID0gZ2V0U2Nyb2xsRXZlbnRWYWx1ZXMoZXZlbnQpO1xuXG4gICAgICBfdGhpcy51cGRhdGVTaGFyZWRTdGF0ZShnZXRHZW5lcmljRXZlbnREYXRhKGV2ZW50KSk7XG5cbiAgICAgIGlmICghX3RoaXMuc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoX2V4dGVuZHMoe30sIGdldFN0YXJ0R2VzdHVyZVN0YXRlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YWx1ZXMsIGV2ZW50KSwgZ2V0R2VuZXJpY1BheWxvYWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIGV2ZW50LCB0cnVlKSwge1xuICAgICAgICAgIGluaXRpYWw6IF90aGlzLnN0YXRlLnZhbHVlc1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdmFyIG1vdmVtZW50RGV0ZWN0aW9uID0gX3RoaXMuZ2V0TW92ZW1lbnQodmFsdWVzKTtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBjYWxjdWxhdGVBbGxHZW9tZXRyeShtb3ZlbWVudERldGVjdGlvbi5kZWx0YSk7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKG1vdmVtZW50RGV0ZWN0aW9uKTtcblxuICAgICAgICBfdGhpcy51cGRhdGVHZXN0dXJlU3RhdGUoZ2VvbWV0cnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBnZXRHZW5lcmljUGF5bG9hZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgZXZlbnQpLCBfdGhpcy5nZXRLaW5lbWF0aWNzKHZhbHVlcywgZXZlbnQpKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmZpcmVHZXN0dXJlSGFuZGxlcigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgX3RoaXMudXBkYXRlR2VzdHVyZVN0YXRlKF9leHRlbmRzKHt9LCBfdGhpcy5nZXRNb3ZlbWVudChfdGhpcy5zdGF0ZS52YWx1ZXMpLCB7XG4gICAgICAgIHZlbG9jaXRpZXM6IFswLCAwXSxcbiAgICAgICAgdmVsb2NpdHk6IDBcbiAgICAgIH0pKTtcblxuICAgICAgX3RoaXMuZmlyZUdlc3R1cmVIYW5kbGVyKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTY3JvbGxSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkQmluZGluZ3MgPSBmdW5jdGlvbiBhZGRCaW5kaW5ncyQxKGJpbmRpbmdzKSB7XG4gICAgYWRkQmluZGluZ3MoYmluZGluZ3MsICdvblNjcm9sbCcsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICB9O1xuXG4gIHJldHVybiBTY3JvbGxSZWNvZ25pemVyO1xufShDb29yZGluYXRlc1JlY29nbml6ZXIpO1xuXG4vKipcclxuICogU2Nyb2xsIGhvb2suXHJcbiAqXHJcbiAqIEBwYXJhbSBoYW5kbGVyIC0gdGhlIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIHNjcm9sbCBnZXN0dXJlIHVwZGF0ZXNcclxuICogQHBhcmFtIFtjb25maWc9e31dIC0gdGhlIGNvbmZpZyBvYmplY3QgaW5jbHVkaW5nIGdlbmVyaWMgb3B0aW9ucyBhbmQgc2Nyb2xsIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIHVzZVNjcm9sbChoYW5kbGVyLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cblxuICBSZWNvZ25pemVyc01hcC5zZXQoJ3Njcm9sbCcsIFNjcm9sbFJlY29nbml6ZXIpO1xuICB2YXIgYnVpbGRTY3JvbGxDb25maWcgPSB1c2VSZWYoKTtcblxuICBpZiAoIWJ1aWxkU2Nyb2xsQ29uZmlnLmN1cnJlbnQpIHtcbiAgICBidWlsZFNjcm9sbENvbmZpZy5jdXJyZW50ID0gbWVtb2l6ZU9uZShfYnVpbGRTY3JvbGxDb25maWcsIGlzRXF1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlY29nbml6ZXJzKHtcbiAgICBzY3JvbGw6IGhhbmRsZXJcbiAgfSwgYnVpbGRTY3JvbGxDb25maWcuY3VycmVudChjb25maWcpKTtcbn1cblxudmFyIFJFX05PVF9OQVRJVkUgPSAvXm9uKERyYWd8V2hlZWx8U2Nyb2xsfE1vdmV8UGluY2h8SG92ZXIpLztcblxuZnVuY3Rpb24gc29ydEhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gIHZhciBfbmF0aXZlID0ge307XG4gIHZhciBoYW5kbGUgPSB7fTtcbiAgdmFyIGFjdGlvbnMgPSBuZXcgU2V0KCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGhhbmRsZXJzKSB7XG4gICAgaWYgKFJFX05PVF9OQVRJVkUudGVzdChrZXkpKSB7XG4gICAgICBhY3Rpb25zLmFkZChSZWdFeHAubGFzdE1hdGNoKTtcbiAgICAgIGhhbmRsZVtrZXldID0gaGFuZGxlcnNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgX25hdGl2ZVtrZXldID0gaGFuZGxlcnNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2hhbmRsZSwgX25hdGl2ZSwgYWN0aW9uc107XG59XG4vKipcclxuICogQHB1YmxpY1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21wbGV0ZSBnZXN0dXJlIGhvb2ssIGFsbG93aW5nIHN1cHBvcnQgZm9yIG11bHRpcGxlIGdlc3R1cmVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hhbmRsZXJzfSBoYW5kbGVycyAtIGFuIG9iamVjdCB3aXRoIG9uW0dlc3R1cmVdIGtleXMgY29udGFpbmcgZ2VzdHVyZSBoYW5kbGVyc1xyXG4gKiBAcGFyYW0ge1VzZUdlc3R1cmVDb25maWd9IFtjb25maWc9e31dIC0gdGhlIGZ1bGwgY29uZmlnIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7KC4uLmFyZ3M6IGFueVtdKSA9PiBIb29rUmV0dXJuVHlwZTxDb25maWc+fVxyXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VHZXN0dXJlKF9oYW5kbGVycywgY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgdmFyIF9zb3J0SGFuZGxlcnMgPSBzb3J0SGFuZGxlcnMoX2hhbmRsZXJzKSxcbiAgICAgIGhhbmRsZXJzID0gX3NvcnRIYW5kbGVyc1swXSxcbiAgICAgIG5hdGl2ZUhhbmRsZXJzID0gX3NvcnRIYW5kbGVyc1sxXSxcbiAgICAgIGFjdGlvbnMgPSBfc29ydEhhbmRsZXJzWzJdO1xuXG4gIFJlY29nbml6ZXJzTWFwLnNldCgnZHJhZycsIERyYWdSZWNvZ25pemVyKTtcbiAgUmVjb2duaXplcnNNYXAuc2V0KCdob3ZlcicsIE1vdmVSZWNvZ25pemVyKTtcbiAgUmVjb2duaXplcnNNYXAuc2V0KCdtb3ZlJywgTW92ZVJlY29nbml6ZXIpO1xuICBSZWNvZ25pemVyc01hcC5zZXQoJ3BpbmNoJywgUGluY2hSZWNvZ25pemVyKTtcbiAgUmVjb2duaXplcnNNYXAuc2V0KCdzY3JvbGwnLCBTY3JvbGxSZWNvZ25pemVyKTtcbiAgUmVjb2duaXplcnNNYXAuc2V0KCd3aGVlbCcsIFdoZWVsUmVjb2duaXplcik7XG4gIHZhciBtZXJnZWRDb25maWcgPSBidWlsZENvbXBsZXhDb25maWcoY29uZmlnLCBhY3Rpb25zKTtcbiAgdmFyIGludGVybmFsSGFuZGxlcnMgPSB7fTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbkRyYWcnKSkgaW50ZXJuYWxIYW5kbGVycy5kcmFnID0gaW5jbHVkZVN0YXJ0RW5kSGFuZGxlcnMoaGFuZGxlcnMsICdvbkRyYWcnKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbldoZWVsJykpIGludGVybmFsSGFuZGxlcnMud2hlZWwgPSBpbmNsdWRlU3RhcnRFbmRIYW5kbGVycyhoYW5kbGVycywgJ29uV2hlZWwnKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvblNjcm9sbCcpKSBpbnRlcm5hbEhhbmRsZXJzLnNjcm9sbCA9IGluY2x1ZGVTdGFydEVuZEhhbmRsZXJzKGhhbmRsZXJzLCAnb25TY3JvbGwnKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbk1vdmUnKSkgaW50ZXJuYWxIYW5kbGVycy5tb3ZlID0gaW5jbHVkZVN0YXJ0RW5kSGFuZGxlcnMoaGFuZGxlcnMsICdvbk1vdmUnKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvblBpbmNoJykpIGludGVybmFsSGFuZGxlcnMucGluY2ggPSBpbmNsdWRlU3RhcnRFbmRIYW5kbGVycyhoYW5kbGVycywgJ29uUGluY2gnKTtcbiAgaWYgKGFjdGlvbnMuaGFzKCdvbkhvdmVyJykpIGludGVybmFsSGFuZGxlcnMuaG92ZXIgPSBoYW5kbGVycy5vbkhvdmVyO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnLCBuYXRpdmVIYW5kbGVycyk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVTdGFydEVuZEhhbmRsZXJzKGhhbmRsZXJzLCBoYW5kbGVyS2V5KSB7XG4gIHZhciBzdGFydEtleSA9IGhhbmRsZXJLZXkgKyAnU3RhcnQnO1xuICB2YXIgZW5kS2V5ID0gaGFuZGxlcktleSArICdFbmQnO1xuXG4gIHZhciBmbiA9IGZ1bmN0aW9uIGZuKHN0YXRlKSB7XG4gICAgdmFyIG1lbW8gPSB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLmZpcnN0ICYmIHN0YXJ0S2V5IGluIGhhbmRsZXJzKSBoYW5kbGVyc1tzdGFydEtleV0oc3RhdGUpO1xuICAgIGlmIChoYW5kbGVyS2V5IGluIGhhbmRsZXJzKSBtZW1vID0gaGFuZGxlcnNbaGFuZGxlcktleV0oc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5sYXN0ICYmIGVuZEtleSBpbiBoYW5kbGVycykgaGFuZGxlcnNbZW5kS2V5XShzdGF0ZSk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBhZGRWLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcywgc3ViViwgdXNlRHJhZywgdXNlR2VzdHVyZSwgdXNlSG92ZXIsIHVzZU1vdmUsIHVzZVBpbmNoLCB1c2VTY3JvbGwsIHVzZVdoZWVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC11c2UtZ2VzdHVyZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-use-gesture/dist/react-use-gesture.esm.js\n");

/***/ })

};
;